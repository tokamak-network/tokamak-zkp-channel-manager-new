Directory structure:
└── test/
    ├── bridge/
    │   ├── Bridge.t.sol
    │   ├── ChannelIdTest.t.sol
    │   ├── ModularArchitectureTest.t.sol
    │   ├── MptKeysAndPubSignals.t.sol
    │   ├── PreAllocatedLeaves.t.sol
    │   ├── ProofSubmission.t.sol
    │   ├── TimeoutWithdrawal.t.sol
    │   ├── UserStorageSlots.t.sol
    │   └── VerifyFinalBalancesInput.t.sol
    ├── frost/
    │   └── ZecFrost.t.sol
    ├── groth16/
    │   ├── 128_leaves/
    │   │   ├── Groth16Verifier128LeavesTest.t.sol
    │   │   ├── proof.json
    │   │   └── public.json
    │   ├── 16_leaves/
    │   │   ├── Groth16Verifier16LeavesTest.t.sol
    │   │   ├── proof.json
    │   │   └── public.json
    │   ├── 32_leaves/
    │   │   ├── Groth16Verifier32LeavesTest.t.sol
    │   │   ├── proof.json
    │   │   └── public.json
    │   └── 64_leaves/
    │       ├── Groth16Verifier64LeavesTest.t.sol
    │       ├── proof.json
    │       └── public.json
    ├── js-scripts/
    │   ├── generate_proof.sh
    │   ├── generateGroth16Proof.js
    │   ├── generateProof.js
    │   ├── merkleTree.js
    │   └── simpleQuaternaryTree.js
    ├── scalability/
    │   └── ChannelScalability.t.sol
    └── verifier/
        ├── Verifier.t.sol
        └── proof1/
            ├── channel5_proof1.json
            └── channel5_proof2.json

================================================
FILE: test/bridge/Bridge.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/BridgeDepositManager.sol";
import "../../src/BridgeWithdrawManager.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/ITokamakVerifier.sol";
import "../../src/interface/IZecFrost.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import "../../src/interface/IGroth16Verifier32Leaves.sol";
import "../../src/interface/IGroth16Verifier64Leaves.sol";
import "../../src/interface/IGroth16Verifier128Leaves.sol";
import {ZecFrost} from "../../src/library/ZecFrost.sol";

// Mock Contracts
contract MockZecFrost is IZecFrost {
    address public mockSigner;

    // Mapping of signature vectors to their recovered addresses
    mapping(bytes32 => address) private signatureVectorToSigner;

    constructor() {
        mockSigner = address(this);

        // Vector 1 signature (valid) - recovers to user1 (0xd96b35D012879d89cfBA6fE215F1015863a6f6d0)
        bytes32 vector1Key = keccak256(
            abi.encodePacked(
                uint256(0x1fb4c0436e9054ae0b237cde3d7a478ce82405b43fdbb5bf1d63c9f8d912dd5d),
                uint256(0x3a7784df441925a8859b9f3baf8d570d488493506437db3ccf230a4b43b27c1e),
                uint256(0xc7fdcb364dd8577e47dd479185ca659adbfcd1b8675e5cbb36e5f93ca4e15b25)
            )
        );
        signatureVectorToSigner[vector1Key] = 0xd96b35D012879d89cfBA6fE215F1015863a6f6d0;

        // Vector 2 signature (invalid) - recovers to user2 (0x012C2171f631e27C4bA9f7f8262af2a48956939A)
        bytes32 vector2Key = keccak256(
            abi.encodePacked(
                uint256(0xc303bb5de5a5962d9af9b45f5e0bdc919de2aac9153b8c353960f50aa3cb950c),
                uint256(0x6df25261f523a8ea346f49dad49b3b36786e653a129cff327a0fea5839e712a2),
                uint256(0x27c26d628367261edb63b64eefc48a192a8130e9cd608b75820775684af010b0)
            )
        );
        signatureVectorToSigner[vector2Key] = 0x012C2171f631e27C4bA9f7f8262af2a48956939A;
    }

    function verify(bytes32, uint256, uint256, uint256 rx, uint256 ry, uint256 z)
        external
        view
        override
        returns (address)
    {
        // Check if this is one of our known signature vectors
        bytes32 vectorKey = keccak256(abi.encodePacked(rx, ry, z));
        address vectorSigner = signatureVectorToSigner[vectorKey];

        if (vectorSigner != address(0)) {
            return vectorSigner;
        }

        // Fall back to mock signer for unknown vectors
        return mockSigner;
    }

    function setMockSigner(address _signer) external {
        mockSigner = _signer;
    }
}

import {TokamakVerifier} from "../../src/verifier/TokamakVerifier.sol";
import {Groth16Verifier16Leaves} from "../../src/verifier/Groth16Verifier16Leaves.sol";
import {Groth16Verifier32Leaves} from "../../src/verifier/Groth16Verifier32Leaves.sol";
import {Groth16Verifier64Leaves} from "../../src/verifier/Groth16Verifier64Leaves.sol";
import {Groth16Verifier128Leaves} from "../../src/verifier/Groth16Verifier128Leaves.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "../../src/library/RLP.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

// Mock Contracts
contract MockTokamakVerifier is ITokamakVerifier {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verify(
        uint128[] calldata,
        uint256[] calldata,
        uint128[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        uint256
    ) external view override returns (bool) {
        return shouldVerify;
    }
}

contract MockGroth16Verifier is IGroth16Verifier16Leaves {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[33] calldata)
        external
        view
        override
        returns (bool)
    {
        return shouldVerify;
    }
}

contract MockGroth16Verifier32 is IGroth16Verifier32Leaves {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[65] calldata)
        external
        view
        override
        returns (bool)
    {
        return shouldVerify;
    }
}

contract MockGroth16Verifier64 is IGroth16Verifier64Leaves {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[129] calldata)
        external
        view
        override
        returns (bool)
    {
        return shouldVerify;
    }
}

contract MockGroth16Verifier128 is IGroth16Verifier128Leaves {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[257] calldata)
        external
        view
        override
        returns (bool)
    {
        return shouldVerify;
    }
}

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK") {
        _mint(msg.sender, 1000000 * 10 ** 18);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// High precision token (27 decimals)
contract HighPrecisionToken is ERC20 {
    constructor() ERC20("High Precision Token", "HPT") {}

    function decimals() public pure override returns (uint8) {
        return 27;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// USDT-like token (6 decimals)
contract USDTLikeToken is ERC20 {
    constructor() ERC20("USDT Like Token", "USDT") {}

    function decimals() public pure override returns (uint8) {
        return 6;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract BridgeCoreTest is Test {
    using RLP for bytes;

    BridgeCore public bridge;
    BridgeProofManager public proofManager;
    BridgeDepositManager public depositManager;
    BridgeWithdrawManager public withdrawManager;
    BridgeAdminManager public adminManager;
    MockTokamakVerifier public tokamakVerifier;
    MockZecFrost public mockZecFrost;
    MockGroth16Verifier public groth16Verifier16;
    MockGroth16Verifier32 public groth16Verifier32;
    MockGroth16Verifier64 public groth16Verifier64;
    MockGroth16Verifier128 public groth16Verifier128;
    MockERC20 public token;
    HighPrecisionToken public highPrecisionToken;
    USDTLikeToken public usdtLikeToken;

    address public owner = address(1);
    address public leader = address(2);
    address public leader2 = address(22);
    address public user1 = 0xd96b35D012879d89cfBA6fE215F1015863a6f6d0; // Address that ZecFrost signature 1 recovers to
    address public user2 = address(3);
    address public user3 = address(4);

    address public l2Leader = address(12);
    address public l2User1 = address(13);
    address public l2User2 = address(14);
    address public l2User3 = address(15);

    uint256 public constant INITIAL_BALANCE = 1000 ether;
    uint256 public constant INITIAL_TOKEN_BALANCE = 1000 * 10 ** 18;

    event ChannelOpened(bytes32 indexed channelId, address indexed targetContract);
    event ChannelFinalized(bytes32 indexed channelId);
    event Deposited(bytes32 indexed channelId, address indexed user, address token, uint256 amount);
    event Withdrawn(bytes32 indexed channelId, address indexed user, address token, uint256 amount);
    event EmergencyWithdrawn(bytes32 indexed channelId, address indexed user, address token, uint256 amount);
    event StateInitialized(bytes32 indexed channelId, bytes32 currentStateRoot);
    event TokamakZkSnarkProofsVerified(bytes32 indexed channelId, address indexed signer);

    function setUp() public {
        // Deploy contracts
        vm.startPrank(owner);

        tokamakVerifier = new MockTokamakVerifier();
        mockZecFrost = new MockZecFrost();
        groth16Verifier16 = new MockGroth16Verifier();
        groth16Verifier32 = new MockGroth16Verifier32();
        groth16Verifier64 = new MockGroth16Verifier64();
        groth16Verifier128 = new MockGroth16Verifier128();
        token = new MockERC20();
        highPrecisionToken = new HighPrecisionToken();
        usdtLikeToken = new USDTLikeToken();

        // Deploy manager implementations
        BridgeDepositManager depositManagerImpl = new BridgeDepositManager();
        BridgeWithdrawManager withdrawManagerImpl = new BridgeWithdrawManager();
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();
        BridgeProofManager proofManagerImpl = new BridgeProofManager();

        // Deploy core contract with proxy first
        BridgeCore implementation = new BridgeCore();
        bytes memory bridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(0), address(0), address(0), address(0), owner) // Temporary addresses
        );
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(implementation), bridgeInitData);
        bridge = BridgeCore(address(bridgeProxy));

        // Deploy manager proxies with bridge address
        bytes memory depositInitData = abi.encodeCall(BridgeDepositManager.initialize, (address(bridge), owner));
        ERC1967Proxy depositProxy = new ERC1967Proxy(address(depositManagerImpl), depositInitData);
        depositManager = BridgeDepositManager(address(depositProxy));

        bytes memory withdrawInitData = abi.encodeCall(BridgeWithdrawManager.initialize, (address(bridge), owner));
        ERC1967Proxy withdrawProxy = new ERC1967Proxy(address(withdrawManagerImpl), withdrawInitData);
        withdrawManager = BridgeWithdrawManager(payable(address(withdrawProxy)));

        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        address[4] memory groth16Verifiers = [
            address(groth16Verifier16),
            address(groth16Verifier32),
            address(groth16Verifier64),
            address(groth16Verifier128)
        ];
        bytes memory proofInitData = abi.encodeCall(
            BridgeProofManager.initialize,
            (address(bridge), address(tokamakVerifier), address(mockZecFrost), groth16Verifiers, owner)
        );
        ERC1967Proxy proofProxy = new ERC1967Proxy(address(proofManagerImpl), proofInitData);
        proofManager = BridgeProofManager(address(proofProxy));

        // Update bridge with manager addresses
        bridge.updateManagerAddresses(
            address(depositManager), address(proofManager), address(withdrawManager), address(adminManager)
        );

        // Configure mock ZecFrost - we'll set the actual expected signer later in tests

        // Fund test accounts
        vm.deal(leader, INITIAL_BALANCE);
        vm.deal(leader2, INITIAL_BALANCE);
        vm.deal(user1, INITIAL_BALANCE);
        vm.deal(user2, INITIAL_BALANCE);
        vm.deal(user3, INITIAL_BALANCE);

        token.mint(leader, INITIAL_TOKEN_BALANCE);
        token.mint(leader2, INITIAL_TOKEN_BALANCE);
        token.mint(user1, INITIAL_TOKEN_BALANCE);
        token.mint(user2, INITIAL_TOKEN_BALANCE);
        token.mint(user3, INITIAL_TOKEN_BALANCE);

        // Mint high precision tokens (2 tokens = 2 * 10^27)
        uint256 highPrecisionAmount = 2 * 10 ** 27;
        highPrecisionToken.mint(user1, highPrecisionAmount);
        highPrecisionToken.mint(user2, highPrecisionAmount);
        highPrecisionToken.mint(user3, highPrecisionAmount);

        // Mint USDT-like tokens (1 token = 1 * 10^6)
        uint256 usdtAmount = 1 * 10 ** 6;
        usdtLikeToken.mint(user1, usdtAmount);
        usdtLikeToken.mint(user2, usdtAmount);
        usdtLikeToken.mint(user3, usdtAmount);

        // Use the correct preprocessed data from ProofSubmission.t.sol
        uint128[] memory preprocessedPart1 = new uint128[](4);
        preprocessedPart1[0] = 0x1136c7a73653af0cbdc9fda441a80391;
        preprocessedPart1[1] = 0x007c86367643476dcdb0e9bcf1617f1c;
        preprocessedPart1[2] = 0x18c9e2822155742dd5fbd050aa293be5;
        preprocessedPart1[3] = 0x00b248168d62853defda478a7a46e0a0;
        uint256[] memory preprocessedPart2 = new uint256[](4);
        preprocessedPart2[0] = 0xc4383bb8c86977fc45c94bc42353e37b39907e30b52054990083a85cf5256c22;
        preprocessedPart2[1] = 0x8fc97f11906d661f0b434c3c49d0ec8b3cac2928f6ff6fac5815686d175d2e87;
        preprocessedPart2[2] = 0xf84798df0fcfbd79e070d2303170d78e438e4b32975a4ebf6e1ff32863f2cc3e;
        preprocessedPart2[3] = 0xc6b05d5e144de6e3b25f09093b9ba94c194452d8decf3af3390cfa46df134c0e;

        // Use the actual registered function instance hash from the deployed contract
        bytes32 functionInstanceHash = 0xd157cb883adb9cb0e27d9dc419e2a4be817d856281b994583b5bae64be94d35a;

        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(token), emptySlots, balanceSlot, true);
        adminManager.setAllowedTargetContract(address(highPrecisionToken), emptySlots, balanceSlot, true);
        adminManager.setAllowedTargetContract(address(usdtLikeToken), emptySlots, balanceSlot, true);

        // Register transfer function for each token using 4-byte selector (standard format)
        bytes32 transferSig = bytes32(bytes4(keccak256("transfer(address,uint256)")));
        adminManager.registerFunction(
            address(token), transferSig, preprocessedPart1, preprocessedPart2, functionInstanceHash
        );
        adminManager.registerFunction(
            address(highPrecisionToken), transferSig, preprocessedPart1, preprocessedPart2, functionInstanceHash
        );
        adminManager.registerFunction(
            address(usdtLikeToken), transferSig, preprocessedPart1, preprocessedPart2, functionInstanceHash
        );

        vm.stopPrank();
    }

    // ========== Helper Functions for ZecFrost Signatures ==========

    /**
     * @dev Creates a ZecFrost signature that verifies against user1 (0xd96b35D012879d89cfBA6fE215F1015863a6f6d0)
     */
    // Using BridgeProofManager.Signature directly

    struct TestChannelInitializationProof {
        uint256[4] pA;
        uint256[8] pB;
        uint256[4] pC;
        bytes32 merkleRoot;
    }

    // Using BridgeProofManager.ProofData and IBridgeCore.RegisteredFunction directly

    function _createZecFrostSignature() internal pure returns (BridgeProofManager.Signature memory) {
        return _createZecFrostSignatureForChannel(bytes32(uint256(1))); // Default test channel ID
    }

    function _createZecFrostSignatureForChannel(bytes32 channelId)
        internal
        pure
        returns (BridgeProofManager.Signature memory)
    {
        // Create commitment hash for the given channel and standard finalStateRoot
        bytes32 finalStateRoot = bytes32(uint256(keccak256("finalStateRoot")));
        bytes32 commitmentHash = keccak256(abi.encodePacked(channelId, finalStateRoot));

        // Return Vector 1 signature data - recovers to 0xd96b35D012879d89cfBA6fE215F1015863a6f6d0 (user1)
        return BridgeProofManager.Signature({
            message: commitmentHash,
            rx: 0x1fb4c0436e9054ae0b237cde3d7a478ce82405b43fdbb5bf1d63c9f8d912dd5d,
            ry: 0x3a7784df441925a8859b9f3baf8d570d488493506437db3ccf230a4b43b27c1e,
            z: 0xc7fdcb364dd8577e47dd479185ca659adbfcd1b8675e5cbb36e5f93ca4e15b25
        });
    }

    function _createZecFrostSignatureForProofData(bytes32 channelId, uint256[] memory publicInputs)
        internal
        pure
        returns (BridgeProofManager.Signature memory)
    {
        // Extract finalStateRoot from proof data (indices 1 and 0)
        bytes32 finalStateRoot = bytes32((publicInputs[1] << 128) | publicInputs[0]);
        bytes32 commitmentHash = keccak256(abi.encodePacked(channelId, finalStateRoot));

        // Return Vector 1 signature data - recovers to 0xd96b35D012879d89cfBA6fE215F1015863a6f6d0 (user1)
        return BridgeProofManager.Signature({
            message: commitmentHash,
            rx: 0x1fb4c0436e9054ae0b237cde3d7a478ce82405b43fdbb5bf1d63c9f8d912dd5d,
            ry: 0x3a7784df441925a8859b9f3baf8d570d488493506437db3ccf230a4b43b27c1e,
            z: 0xc7fdcb364dd8577e47dd479185ca659adbfcd1b8675e5cbb36e5f93ca4e15b25
        });
    }

    /**
     * @dev Creates a ZecFrost signature that verifies against user2 (0x012C2171f631e27C4bA9f7f8262af2a48956939A)
     */
    function _createWrongZecFrostSignature() internal pure returns (BridgeProofManager.Signature memory) {
        return _createWrongZecFrostSignatureForChannel(bytes32(uint256(1))); // Default test channel ID
    }

    function _createWrongZecFrostSignatureForChannel(bytes32 channelId)
        internal
        pure
        returns (BridgeProofManager.Signature memory)
    {
        // Create commitment hash for the given channel and finalStateRoot
        bytes32 finalStateRoot = bytes32(uint256(keccak256("finalStateRoot")));
        bytes32 commitmentHash = keccak256(abi.encodePacked(channelId, finalStateRoot));

        // Return Vector 2 signature data - recovers to 0x012C2171f631e27C4bA9f7f8262af2a48956939A (user2)
        return BridgeProofManager.Signature({
            message: commitmentHash,
            rx: 0xc303bb5de5a5962d9af9b45f5e0bdc919de2aac9153b8c353960f50aa3cb950c,
            ry: 0x6df25261f523a8ea346f49dad49b3b36786e653a129cff327a0fea5839e712a2,
            z: 0x27c26d628367261edb63b64eefc48a192a8130e9cd608b75820775684af010b0
        });
    }

    // ========== Helper Functions for Channel Creation ==========

    function _createChannelParams() internal view returns (BridgeCore.ChannelParams memory) {
        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        return BridgeCore.ChannelParams({
            channelId: keccak256(abi.encode(address(this), uint256(1))),
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
    }

    function _createGroth16Proof(bytes32 merkleRoot) internal pure returns (TestChannelInitializationProof memory) {
        // Mock Groth16 proof data
        uint256[4] memory pA = [uint256(1), uint256(2), uint256(3), uint256(4)];
        uint256[8] memory pB =
            [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)];
        uint256[4] memory pC = [uint256(13), uint256(14), uint256(15), uint256(16)];

        return TestChannelInitializationProof({pA: pA, pB: pB, pC: pC, merkleRoot: merkleRoot});
    }

    // ========== Helper Functions for MPT Leaves ==========

    /**
     * @dev Creates a mock MPT leaf with RLP-encoded account data: [nonce, balance, storageHash, codeHash]
     */
    function _createMockMPTLeaf(uint256 balance) internal pure returns (bytes memory) {
        bytes[] memory accountFields = new bytes[](4);

        // nonce = 0
        accountFields[0] = RLP.encode(abi.encodePacked(uint256(0)));

        // balance
        accountFields[1] = RLP.encode(abi.encodePacked(balance));

        // storageHash (empty storage)
        accountFields[2] = RLP.encode(abi.encodePacked(keccak256("")));

        // codeHash (empty code)
        accountFields[3] = RLP.encode(abi.encodePacked(keccak256("")));

        return RLP.encodeList(accountFields);
    }

    /**
     * @dev Creates MPT leaves for a given set of balances
     */
    function _createMPTLeaves(uint256[] memory balances) internal pure returns (bytes[] memory) {
        bytes[] memory leaves = new bytes[](balances.length);
        for (uint256 i = 0; i < balances.length; i++) {
            leaves[i] = _createMockMPTLeaf(balances[i]);
        }
        return leaves;
    }

    /**
     * @dev Creates ProofData struct for testing
     */
    function _createProofData(
        uint128[] memory proofPart1,
        uint256[] memory proofPart2,
        uint256[] memory publicInputs,
        uint256 smax,
        uint256[] memory finalBalances
    ) internal pure returns (BridgeProofManager.ProofData memory, uint256[] memory) {
        BridgeProofManager.ProofData memory proofData = BridgeProofManager.ProofData({
            proofPart1: proofPart1,
            proofPart2: proofPart2,
            publicInputs: publicInputs,
            smax: smax
        });
        return (proofData, finalBalances);
    }

    /**
     * @dev Creates mock participant roots for testing
     */
    function _createMockParticipantRoots(uint256 count) internal pure returns (bytes32[] memory) {
        bytes32[] memory participantRoots = new bytes32[](count);
        for (uint256 i = 0; i < count; i++) {
            // Generate deterministic mock roots based on participant index
            participantRoots[i] = keccak256(abi.encodePacked("participant_root", i));
        }
        return participantRoots;
    }

    /**
     * @dev Creates ProofData struct for testing with mock participantRoots (for backwards compatibility)
     * This version handles the old signature for existing tests
     */
    function _createProofDataSimple(
        uint128[] memory proofPart1,
        uint256[] memory proofPart2,
        uint256[] memory publicInputs,
        uint256 smax,
        bytes[] memory, /* initialMPTLeaves */
        bytes[] memory finalMPTLeaves
    ) internal view returns (BridgeProofManager.ProofData memory, uint256[] memory) {
        // Set proper state root values for bridge tests to pass state root chain validation
        _setTestStateRoots(publicInputs, bytes32(uint256(0))); // Assume channel 0 for now
        return _createProofDataFromMPT(proofPart1, proofPart2, publicInputs, smax, finalMPTLeaves);
    }

    function _createProofDataSimpleForChannel(
        bytes32 channelId,
        uint128[] memory proofPart1,
        uint256[] memory proofPart2,
        uint256[] memory publicInputs,
        uint256 smax,
        bytes[] memory, /* initialMPTLeaves */
        bytes[] memory finalMPTLeaves
    ) internal view returns (BridgeProofManager.ProofData memory, uint256[] memory) {
        // Set proper state root values for bridge tests to pass state root chain validation
        _setTestStateRoots(publicInputs, channelId);
        return _createProofDataFromMPT(proofPart1, proofPart2, publicInputs, smax, finalMPTLeaves);
    }

    function _setTestStateRoots(uint256[] memory publicInputs, bytes32 channelId) internal view {
        if (publicInputs.length >= 12) {
            // Use the actual initial state root from the specified channel
            bytes32 actualInitialRoot = bridge.getChannelInitialStateRoot(channelId);
            uint256 inputRootHigh = uint256(actualInitialRoot) >> 128;
            uint256 inputRootLow = uint256(actualInitialRoot) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            // Use the finalStateRoot (which is set in publicInputs[0]) for output
            // Note: publicInputs[0] is currently set to the full keccak256("finalStateRoot") hash
            bytes32 finalStateRoot = bytes32(publicInputs[0]);
            uint256 outputRootHigh = uint256(finalStateRoot) >> 128;
            uint256 outputRootLow = uint256(finalStateRoot) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            publicInputs[8] = inputRootLow; // input state root low
            publicInputs[9] = inputRootHigh; // input state root high
            publicInputs[0] = outputRootLow; // output state root low
            publicInputs[1] = outputRootHigh; // output state root high
        }

        // Set function signature at index 14 (transfer function selector: 0xa9059cbb)
        if (publicInputs.length >= 17) {
            publicInputs[14] = 0xa9059cbb; // transfer(address,uint256) function selector
        }
        // Set function instance data (indices 66-511) to match computeCorrectFunctionInstanceHash
        _setFunctionInstanceData(publicInputs);
    }

    // Overloaded version for pure functions that can't access bridge state
    function _setTestStateRoots(uint256[] memory publicInputs) internal pure {
        if (publicInputs.length >= 12) {
            // Use the hardcoded mock root for pure functions
            bytes32 mockRoot = keccak256(abi.encodePacked("mockRoot"));
            uint256 inputRootHigh = uint256(mockRoot) >> 128;
            uint256 inputRootLow = uint256(mockRoot) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            // Use the finalStateRoot (which is set in publicInputs[0]) for output
            bytes32 finalStateRoot = bytes32(publicInputs[0]);
            uint256 outputRootHigh = uint256(finalStateRoot) >> 128;
            uint256 outputRootLow = uint256(finalStateRoot) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            publicInputs[8] = inputRootLow; // input state root low
            publicInputs[9] = inputRootHigh; // input state root high
            publicInputs[0] = outputRootLow; // output state root low
            publicInputs[1] = outputRootHigh; // output state root high
        }

        // Set function signature at index 14 (transfer function selector: 0xa9059cbb)
        if (publicInputs.length >= 17) {
            publicInputs[14] = 0xa9059cbb; // transfer(address,uint256) function selector
        }
        // Set function instance data (indices 66-511) to match computeCorrectFunctionInstanceHash
        _setFunctionInstanceData(publicInputs);
    }

    function _setFunctionInstanceData(uint256[] memory publicInputs) internal pure {
        if (publicInputs.length < 512) return; // Need at least 512 elements for function instance data

        // Call the helper that creates the same function instances array
        uint256[] memory functionInstances = _getCorrectFunctionInstanceData();

        // Set the function instance data in publicInputs starting at index 64
        for (uint256 i = 0; i < 446 && (64 + i) < publicInputs.length; i++) {
            publicInputs[64 + i] = functionInstances[i];
        }
    }

    function _getCorrectFunctionInstanceData() internal pure returns (uint256[] memory) {
        // Exact copy of the function instance data from computeCorrectFunctionInstanceHash
        uint256[] memory functionInstances = new uint256[](446);

        // All 181 assignments copied from computeCorrectFunctionInstanceHash
        functionInstances[0] = 0x01;
        functionInstances[1] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[2] = 0xffffffff;
        functionInstances[3] = 0xe72f6afd7d1f72623e6b071492d1122b;
        functionInstances[4] = 0x11dafe5d23e1218086a365b99fbf3d3b;
        functionInstances[5] = 0x3e26ba5cc220fed7cc3f870e59d292aa;
        functionInstances[6] = 0x1d523cf1ddab1a1793132e78c866c0c3;
        functionInstances[7] = 0x00;
        functionInstances[8] = 0x00;
        functionInstances[9] = 0x01;
        functionInstances[10] = 0x00;
        functionInstances[11] = 0x80;
        functionInstances[12] = 0x00;
        functionInstances[13] = 0x00;
        functionInstances[14] = 0x00;
        functionInstances[15] = 0x200000;
        functionInstances[16] = 0x04;
        functionInstances[17] = 0x00;
        functionInstances[18] = 0x44;
        functionInstances[19] = 0x00;
        functionInstances[20] = 0x010000;
        functionInstances[21] = 0xe0;
        functionInstances[22] = 0x00;
        functionInstances[23] = 0x08000000;
        functionInstances[24] = 0x20;
        functionInstances[25] = 0x00;
        functionInstances[26] = 0x10000000;
        functionInstances[27] = 0xe0;
        functionInstances[28] = 0x00;
        functionInstances[29] = 0x10000000;
        functionInstances[30] = 0x70a08231;
        functionInstances[31] = 0x00;
        functionInstances[32] = 0x100000;
        functionInstances[33] = 0x095ea7b3;
        functionInstances[34] = 0x00;
        functionInstances[35] = 0x100000;
        functionInstances[36] = 0x23b872dd;
        functionInstances[37] = 0x00;
        functionInstances[38] = 0x100000;
        functionInstances[39] = 0x18160ddd;
        functionInstances[40] = 0x00;
        functionInstances[41] = 0x100000;
        functionInstances[42] = 0x313ce567;
        functionInstances[43] = 0x00;
        functionInstances[44] = 0x100000;
        functionInstances[45] = 0x06fdde03;
        functionInstances[46] = 0x00;
        functionInstances[47] = 0x100000;
        functionInstances[48] = 0x95d89b41;
        functionInstances[49] = 0x00;
        functionInstances[50] = 0x100000;
        functionInstances[51] = 0x39509351;
        functionInstances[52] = 0x00;
        functionInstances[53] = 0x100000;
        functionInstances[54] = 0xa457c2d7;
        functionInstances[55] = 0x00;
        functionInstances[56] = 0x100000;
        functionInstances[57] = 0xa9059cbb;
        functionInstances[58] = 0x00;
        functionInstances[59] = 0x100000;
        functionInstances[60] = 0x04;
        functionInstances[61] = 0x00;
        functionInstances[62] = 0x44;
        functionInstances[63] = 0x00;
        functionInstances[64] = 0x08;
        functionInstances[65] = 0x40;
        functionInstances[66] = 0x00;
        functionInstances[67] = 0x010000;
        functionInstances[68] = 0x200000;
        functionInstances[69] = 0x02;
        functionInstances[70] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[71] = 0xffffffff;
        functionInstances[72] = 0x20;
        functionInstances[73] = 0x00;
        functionInstances[74] = 0x02;
        functionInstances[75] = 0x20;
        functionInstances[76] = 0x00;
        functionInstances[77] = 0x04;
        functionInstances[78] = 0x00;
        functionInstances[79] = 0x01;
        functionInstances[80] = 0x00;
        functionInstances[81] = 0x00;
        functionInstances[82] = 0x00;
        functionInstances[83] = 0x00;
        functionInstances[84] = 0x01;
        functionInstances[85] = 0x00;
        functionInstances[86] = 0x00;
        functionInstances[87] = 0x00;
        functionInstances[88] = 0x00;
        functionInstances[89] = 0x01;
        functionInstances[90] = 0x00;
        functionInstances[91] = 0x00;
        functionInstances[92] = 0x00;
        functionInstances[93] = 0x00;
        functionInstances[94] = 0x01;
        functionInstances[95] = 0x00;
        functionInstances[96] = 0x00;
        functionInstances[97] = 0x00;
        functionInstances[98] = 0x00;
        functionInstances[99] = 0x01;
        functionInstances[100] = 0x00;
        functionInstances[101] = 0x00;
        functionInstances[102] = 0x00;
        functionInstances[103] = 0x00;
        functionInstances[104] = 0x01;
        functionInstances[105] = 0x00;
        functionInstances[106] = 0x00;
        functionInstances[107] = 0x00;
        functionInstances[108] = 0x00;
        functionInstances[109] = 0x01;
        functionInstances[110] = 0x00;
        functionInstances[111] = 0x00;
        functionInstances[112] = 0x00;
        functionInstances[113] = 0x00;
        functionInstances[114] = 0x01;
        functionInstances[115] = 0x00;
        functionInstances[116] = 0x00;
        functionInstances[117] = 0x00;
        functionInstances[118] = 0x00;
        functionInstances[119] = 0x01;
        functionInstances[120] = 0x00;
        functionInstances[121] = 0x00;
        functionInstances[122] = 0x00;
        functionInstances[123] = 0x00;
        functionInstances[124] = 0x01;
        functionInstances[125] = 0x00;
        functionInstances[126] = 0x020000;
        functionInstances[127] = 0x70a08231;
        functionInstances[128] = 0x00;
        functionInstances[129] = 0x100000;
        functionInstances[130] = 0x02;
        functionInstances[131] = 0x00;
        functionInstances[132] = 0x04;
        functionInstances[133] = 0x00;
        functionInstances[134] = 0x00;
        functionInstances[135] = 0x40;
        functionInstances[136] = 0x00;
        functionInstances[137] = 0x08;
        functionInstances[138] = 0x00;
        functionInstances[139] = 0x40;
        functionInstances[140] = 0x00;
        functionInstances[141] = 0x10000001;
        functionInstances[142] = 0x04;
        functionInstances[143] = 0x00;
        functionInstances[144] = 0x24;
        functionInstances[145] = 0x00;
        functionInstances[146] = 0x08;
        functionInstances[147] = 0x40;
        functionInstances[148] = 0x00;
        functionInstances[149] = 0x200000;
        functionInstances[150] = 0x020000;
        functionInstances[151] = 0x095ea7b3;
        functionInstances[152] = 0x00;
        functionInstances[153] = 0x100000;
        functionInstances[154] = 0x23b872dd;
        functionInstances[155] = 0x00;
        functionInstances[156] = 0x100000;
        functionInstances[157] = 0x18160ddd;
        functionInstances[158] = 0x00;
        functionInstances[159] = 0x100000;
        functionInstances[160] = 0x313ce567;
        functionInstances[161] = 0x00;
        functionInstances[162] = 0x100000;
        functionInstances[163] = 0x06fdde03;
        functionInstances[164] = 0x00;
        functionInstances[165] = 0x100000;
        functionInstances[166] = 0x95d89b41;
        functionInstances[167] = 0x00;
        functionInstances[168] = 0x100000;
        functionInstances[169] = 0x39509351;
        functionInstances[170] = 0x00;
        functionInstances[171] = 0x100000;
        functionInstances[172] = 0xa457c2d7;
        functionInstances[173] = 0x00;
        functionInstances[174] = 0x100000;
        functionInstances[175] = 0xa9059cbb;
        functionInstances[176] = 0x00;
        functionInstances[177] = 0x100000;
        functionInstances[178] = 0x04;
        functionInstances[179] = 0x00;
        functionInstances[180] = 0x44;

        // Rest remain zero (indices 181-445 are default initialized to 0)
        return functionInstances;
    }

    /**
     * @dev Helper function to create a simple proof data for tests that still use old MPT structure
     * Converts old MPT-based calls to new function-based structure
     */
    function _createProofDataFromMPT(
        uint128[] memory proofPart1,
        uint256[] memory proofPart2,
        uint256[] memory publicInputs,
        uint256 smax,
        bytes[] memory finalMPTLeaves
    ) internal pure returns (BridgeProofManager.ProofData memory, uint256[] memory) {
        // Set proper state root values and function signature for bridge tests
        _setTestStateRoots(publicInputs);

        // Create final balances array - we'll decode the intended values from the leaf count pattern
        uint256 participantCount = finalMPTLeaves.length;
        uint256[] memory finalBalances = new uint256[](participantCount);

        // Simple pattern based on participant count to avoid stack too deep
        if (smax == 6 && participantCount == 3) {
            // testSubmitAggregatedProof expects redistribution (6,0,0)
            finalBalances[0] = 6 ether;
            finalBalances[1] = 0 ether;
            finalBalances[2] = 0 ether;
        } else {
            // Default: each participant gets (i+1) ether to match deposit pattern
            for (uint256 i = 0; i < participantCount; i++) {
                finalBalances[i] = (i + 1) * 1 ether;
            }
        }

        BridgeProofManager.ProofData memory proofData = BridgeProofManager.ProofData({
            proofPart1: proofPart1,
            proofPart2: proofPart2,
            publicInputs: publicInputs,
            smax: smax
        });

        return (proofData, finalBalances);
    }

    /**
     * @dev Helper function to create proof data with non-conserving balances for violation tests
     */
    function _createProofDataViolatingConservation(
        uint128[] memory proofPart1,
        uint256[] memory proofPart2,
        uint256[] memory publicInputs,
        uint256 smax
    ) internal pure returns (BridgeProofManager.ProofData memory, uint256[] memory) {
        // Set proper state root values for bridge tests to pass state root chain validation
        _setTestStateRoots(publicInputs);

        // Create final balances that violate conservation (total 7 instead of 6)
        uint256[] memory finalBalances = new uint256[](3);
        finalBalances[0] = 2 ether; // Total will be 2+2+3=7 ether, violating conservation
        finalBalances[1] = 2 ether;
        finalBalances[2] = 3 ether;

        BridgeProofManager.ProofData memory proofData = BridgeProofManager.ProofData({
            proofPart1: proofPart1,
            proofPart2: proofPart2,
            publicInputs: publicInputs,
            smax: smax
        });

        return (proofData, finalBalances);
    }

    // ========== Channel Opening Tests ==========

    function testOpenChannel() public {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 channelId = keccak256(abi.encode(address(this), uint256(2)));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
        bytes32 returnedChannelId = bridge.openChannel(params);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        assertEq(returnedChannelId, channelId);

        BridgeCore.ChannelState state = bridge.getChannelState(channelId);
        address targetContractReturned = bridge.getChannelTargetContract(channelId);
        address[] memory channelParticipants = bridge.getChannelParticipants(channelId);

        assertEq(targetContractReturned, address(token));
        assertEq(uint8(state), uint8(BridgeCore.ChannelState.Initialized));

        // Check that all participants are whitelisted
        assertTrue(bridge.isChannelWhitelisted(channelId, user1));
        assertTrue(bridge.isChannelWhitelisted(channelId, user2));
        assertTrue(bridge.isChannelWhitelisted(channelId, user3));

        assertEq(channelParticipants.length, 0); // No deposits made yet

        vm.stopPrank();
    }

    function testParticipantCountOverflow() public {
        vm.startPrank(leader);

        // Create 16 participants (NOT including the leader)
        address[] memory participants = new address[](16);
        for (uint256 i = 0; i < 16; i++) {
            participants[i] = address(uint160(1000 + i));
            token.mint(participants[i], 10 ether);
        }

        // Open channel - leader will be auto-whitelisted as 17th participant
        bytes32 channelId = keccak256(abi.encode(leader, "overflow-test"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: false
        });
        bridge.openChannel(params);

        vm.stopPrank();

        // Verify tree size - should be 32, not 16
        uint256 treeSize = bridge.getChannelTreeSize(channelId);

        // Now have leader + 16 whitelisted users deposit
        // This creates 17 participants for a tree that might only support 16

        // Leader deposits
        vm.startPrank(leader);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory leaderMptKeys = new bytes32[](1);
        leaderMptKeys[0] = bytes32(uint256(1));
        depositManager.depositToken(channelId, 1 ether, leaderMptKeys);
        vm.stopPrank();

        // All 16 participants deposit
        for (uint256 i = 0; i < 16; i++) {
            vm.startPrank(participants[i]);
            token.approve(address(depositManager), 1 ether);
            bytes32[] memory mptKeys = new bytes32[](1);
            mptKeys[0] = bytes32(uint256(2 + i));
            depositManager.depositToken(channelId, 1 ether, mptKeys);
            vm.stopPrank();
        }

        // Get participant count
        address[] memory channelParticipants = bridge.getChannelParticipants(channelId);

        // Should have 17 participants total

        assertEq(channelParticipants.length, 17, "Should have 17 participants");

        // Tree size must accommodate all participants
        assertTrue(treeSize >= channelParticipants.length, "Tree size must be >= participant count");
    }

    function testMultipleChannelsWithSameLeader() public {
        vm.startPrank(leader);

        address[] memory participants = new address[](2);
        participants[0] = user1;
        participants[1] = user2;

        // Create first channel
        bytes32 channelId1 = keccak256(abi.encode(leader, "channel1"));
        BridgeCore.ChannelParams memory params1 = BridgeCore.ChannelParams({
            channelId: channelId1,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: false
        });
        bridge.openChannel(params1);

        // Create second channel with same leader
        bytes32 channelId2 = keccak256(abi.encode(leader, "channel2"));
        BridgeCore.ChannelParams memory params2 = BridgeCore.ChannelParams({
            channelId: channelId2,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: false
        });
        bridge.openChannel(params2);

        vm.stopPrank();

        // Verify leader is set for both channels
        assertTrue(bridge.isMarkedChannelLeader(leader, channelId1), "Leader should be marked for channel 1");
        assertTrue(bridge.isMarkedChannelLeader(leader, channelId2), "Leader should be marked for channel 2");

        // Cleanup first channel
        vm.prank(address(withdrawManager));
        bridge.cleanupChannel(channelId1);

        // Verify first channel is deleted but second still exists
        assertEq(bridge.getChannelLeader(channelId1), address(0), "First channel should be deleted");
        assertFalse(bridge.isMarkedChannelLeader(leader, channelId1), "Leader should not be marked for deleted channel 1");
        assertTrue(
            bridge.isMarkedChannelLeader(leader, channelId2),
            "Leader should still be marked for channel 2"
        );

        // Cleanup second channel
        vm.prank(address(withdrawManager));
        bridge.cleanupChannel(channelId2);

        // Now both channels should be deleted
        assertEq(bridge.getChannelLeader(channelId2), address(0), "Second channel should be deleted");
        assertFalse(
            bridge.isMarkedChannelLeader(leader, channelId2),
            "Leader should not be marked for deleted channel 2"
        );
    }

    // ========== Deposit Tests ==========

    function testDepositTokenBasic() public {
        bytes32 channelId = _createChannel();
        uint256 depositAmount = 1 ether;

        vm.startPrank(user1);

        // Approve and deposit token
        token.approve(address(depositManager), depositAmount);

        vm.expectEmit(true, true, true, true);
        emit Deposited(channelId, user1, address(token), depositAmount);
        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId, depositAmount, mptKeys);
        uint256 amountStored = bridge.getValidatedUserSlotValue(channelId, user1, 0);
        assertEq(amountStored, depositAmount);

        vm.stopPrank();
    }

    function testDepositTokenNotParticipant() public {
        bytes32 channelId = _createChannel();

        vm.startPrank(address(999));
        token.mint(address(999), 1 ether);
        token.approve(address(depositManager), 1 ether);
        vm.expectRevert("Not whitelisted");
        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId, 1 ether, mptKeys);
        vm.stopPrank();
    }

    function testDepositToken() public {
        bytes32 channelId = _createTokenChannel();
        uint256 depositAmount = 100 * 10 ** 18;

        vm.startPrank(user1);

        token.approve(address(depositManager), depositAmount);

        vm.expectEmit(true, true, true, true);
        emit Deposited(channelId, user1, address(token), depositAmount);

        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId, depositAmount, mptKeys);

        assertEq(token.balanceOf(address(depositManager)), depositAmount);

        vm.stopPrank();
    }

    // ========== State Initialization Tests ==========

    function testInitializeChannelState() public {
        bytes32 channelId = _createChannel();

        // Leader must deposit before initializing
        vm.startPrank(leader);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(uint160(l2Leader)));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Make deposits using DepositManager
        vm.startPrank(user1);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId, 1 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user3);
        token.approve(address(depositManager), 3 ether);
        bytes32[] memory mptKeys3 = new bytes32[](1);
        mptKeys3[0] = bytes32(uint256(uint160(l2User3)));
        depositManager.depositToken(channelId, 3 ether, mptKeys3);
        vm.stopPrank();

        // Initialize state
        bytes32 mockMerkleRoot = keccak256(abi.encodePacked("mockRoot"));
        TestChannelInitializationProof memory mockProof = TestChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: mockMerkleRoot
        });
        vm.roll(10); // Set block number high enough to avoid underflow in block.number - 3
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: mockProof.pA,
                pB: mockProof.pB,
                pC: mockProof.pC,
                merkleRoot: mockProof.merkleRoot
            })
        );

        // Check state using individual getters since getChannelInfo doesn't exist
        BridgeCore.ChannelState state = bridge.getChannelState(channelId);

        assertEq(uint8(state), uint8(BridgeCore.ChannelState.Open));
    }

    /**
     * @notice Tests that initializeChannelState produces different root hashes for channels
     *         with the same participants but different deposit amounts
     * @dev This test verifies the fix for the bug where different deposits produced identical hashes
     */
    function testInitializeChannelStateDifferentDeposits() public {
        // Simplified test: just verify that token channels with different deposits create different root hashes
        // Use tokens to match working patterns exactly

        // Create first channel
        bytes32 channelId1 = _createChannel();

        // Leader must deposit before initializing
        vm.startPrank(leader);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(uint160(l2Leader)));
        depositManager.depositToken(channelId1, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Make specific deposits - Set 1: [1, 2, 0]
        vm.startPrank(user1);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId1, 1 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        token.approve(address(depositManager), 2 ether);
        bytes32[] memory mptKeys2 = new bytes32[](1);
        mptKeys2[0] = bytes32(uint256(uint160(l2User2)));
        depositManager.depositToken(channelId1, 2 ether, mptKeys2);
        vm.stopPrank();
        // user3 makes no deposit

        // Initialize and get root hash 1
        bytes32 mockMerkleRoot1 = keccak256(abi.encodePacked("mockRoot1"));
        TestChannelInitializationProof memory mockProof1 = TestChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: mockMerkleRoot1
        });
        vm.roll(15); // Set block number high enough to avoid underflow in block.number - 3
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId1,
            BridgeProofManager.ChannelInitializationProof({
                pA: mockProof1.pA,
                pB: mockProof1.pB,
                pC: mockProof1.pC,
                merkleRoot: mockProof1.merkleRoot
            })
        );
        (,,, bytes32 rootHash1) = bridge.getChannelInfo(channelId1);

        // Simple approach: just verify the root hashes are different after initialization
        // No need to complete full lifecycle for this test

        // Create second channel with different leader to avoid "Channel limit reached"
        bytes32 channelId2 = _createChannelWithLeader(leader2);

        // Leader2 must deposit before initializing
        vm.startPrank(leader2);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader2 = new bytes32[](1);
        mptKeysLeader2[0] = bytes32(uint256(uint160(address(32)))); // l2Leader2
        depositManager.depositToken(channelId2, 1 ether, mptKeysLeader2);
        vm.stopPrank();

        vm.startPrank(user1);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysC2_1 = new bytes32[](1);
        mptKeysC2_1[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId2, 1 ether, mptKeysC2_1);
        vm.stopPrank();

        vm.startPrank(user2);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysC2_2 = new bytes32[](1);
        mptKeysC2_2[0] = bytes32(uint256(uint160(l2User2)));
        depositManager.depositToken(channelId2, 1 ether, mptKeysC2_2); // Same amount this time
        vm.stopPrank();
        // user3 makes no deposit

        // Initialize and get root hash 2
        bytes32 mockMerkleRoot2 = keccak256(abi.encodePacked("mockRoot2"));
        TestChannelInitializationProof memory mockProof2 = TestChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: mockMerkleRoot2
        });
        vm.roll(20); // Set block number high enough to avoid underflow in block.number - 3
        vm.prank(leader2);
        proofManager.initializeChannelState(
            channelId2,
            BridgeProofManager.ChannelInitializationProof({
                pA: mockProof2.pA,
                pB: mockProof2.pB,
                pC: mockProof2.pC,
                merkleRoot: mockProof2.merkleRoot
            })
        );
        (,,, bytes32 rootHash2) = bridge.getChannelInfo(channelId2);

        // The root hashes should be different for different deposit amounts
        assertTrue(rootHash1 != rootHash2, "Root hashes should be different for different deposit amounts");
    }

    function testInitialize_ChannelStateNotLeader() public {
        bytes32 channelId = _createChannel();

        bytes32 mockMerkleRoot = keccak256(abi.encodePacked("mockRoot"));
        TestChannelInitializationProof memory mockProof = TestChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: mockMerkleRoot
        });
        vm.prank(user1);
        vm.expectRevert("Not leader");
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: mockProof.pA,
                pB: mockProof.pB,
                pC: mockProof.pC,
                merkleRoot: mockProof.merkleRoot
            })
        );
    }

    function _createChannel() internal returns (bytes32) {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "createChannel"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        vm.stopPrank();

        return channelId;
    }

    function _createTokenChannel() internal returns (bytes32) {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "createTokenChannel"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        vm.stopPrank();

        return channelId;
    }

    function _createChannelWithLeader(address newLeader) internal returns (bytes32) {
        vm.startPrank(newLeader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 channelId = keccak256(abi.encode(address(this), newLeader, block.timestamp, "createChannelWithLeader"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        vm.stopPrank();

        return channelId;
    }

    function _initializeChannel() internal returns (bytes32) {
        bytes32 channelId = _createChannel();

        // Configure MockZecFrost to accept the channel's expected signer
        address expectedSigner = bridge.getChannelSignerAddr(channelId);
        mockZecFrost.setMockSigner(expectedSigner);

        // Leader must deposit before initializing
        vm.startPrank(leader);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(uint160(l2Leader)));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Make deposits
        vm.startPrank(user1);
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId, 1 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        token.approve(address(depositManager), 2 ether);
        bytes32[] memory mptKeys2 = new bytes32[](1);
        mptKeys2[0] = bytes32(uint256(uint160(l2User2)));
        depositManager.depositToken(channelId, 2 ether, mptKeys2);
        vm.stopPrank();

        vm.startPrank(user3);
        token.approve(address(depositManager), 3 ether);
        bytes32[] memory mptKeys3 = new bytes32[](1);
        mptKeys3[0] = bytes32(uint256(uint160(l2User3)));
        depositManager.depositToken(channelId, 3 ether, mptKeys3);
        vm.stopPrank();

        // Initialize state
        bytes32 mockMerkleRoot = keccak256(abi.encodePacked("mockRoot"));
        TestChannelInitializationProof memory mockProof = TestChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: mockMerkleRoot
        });
        vm.roll(25); // Set block number high enough to avoid underflow in block.number - 3
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: mockProof.pA,
                pB: mockProof.pB,
                pC: mockProof.pC,
                merkleRoot: mockProof.merkleRoot
            })
        );

        return channelId;
    }

    function _submitProof() internal returns (bytes32) {
        bytes32 channelId = _initializeChannel();

        uint128[] memory proofPart1 = new uint128[](1);
        uint256[] memory proofPart2 = new uint256[](1);
        uint256[] memory publicInputs = new uint256[](512);
        publicInputs[0] = uint256(keccak256("finalStateRoot"));

        // Create MPT leaves matching the deposited amounts
        uint256[] memory balances = new uint256[](3);
        balances[0] = 1 ether;
        balances[1] = 2 ether;
        balances[2] = 3 ether;

        bytes[] memory initialMPTLeaves = _createMPTLeaves(balances);
        bytes[] memory finalMPTLeaves = _createMPTLeaves(balances);

        // Advance time past the channel timeout to allow proof submission
        vm.warp(block.timestamp + 1 days + 1);

        vm.prank(leader);
        (BridgeProofManager.ProofData memory proofDataLocal,) = _createProofDataSimpleForChannel(
            channelId, proofPart1, proofPart2, publicInputs, 0, initialMPTLeaves, finalMPTLeaves
        );
        proofManager.submitProofAndSignature(
            channelId,
            _wrapProofInArray(proofDataLocal),
            _createZecFrostSignatureForProofData(channelId, proofDataLocal.publicInputs)
        );

        return channelId;
    }

    function _getSignedChannel() internal returns (bytes32) {
        // _submitProof now includes signature, so it's already signed and in Closing state
        return _submitProof();
    }

    function _getClosedChannel() internal returns (bytes32) {
        bytes32 channelId = _getSignedChannel();

        vm.prank(leader);

        return channelId;
    }

    // ========== Fuzz Tests ==========

    function testFuzzDeposit(uint256 amount) public {
        vm.assume(amount > 0 && amount < 100 ether);

        bytes32 channelId = _createChannel();

        vm.deal(user1, amount);
        vm.startPrank(user1);
        token.approve(address(depositManager), amount);
        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(uint256(uint160(l2User1)));
        depositManager.depositToken(channelId, amount, mptKeys);
        vm.stopPrank();
    }

    function testFuzzTimeout(uint256 timeout) public {
        vm.assume(timeout >= 1 hours && timeout <= 7 days);

        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 testChannelId = keccak256(abi.encode(address(this), timeout, "testFuzzTimeout"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: testChannelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
        bytes32 channelId = bridge.openChannel(params);
        assertEq(channelId, testChannelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        vm.stopPrank();
    }

    // ========== Integration Tests ==========

    function testSignatureCommitmentProtection() public {
        bytes32 channelId = _initializeChannel();
        uint128[] memory proofPart1 = new uint128[](1);
        uint256[] memory proofPart2 = new uint256[](1);

        // Malicious proof with different final state root
        uint256[] memory maliciousPublicInputs = new uint256[](512);
        maliciousPublicInputs[0] = uint256(keccak256("maliciousStateRoot"));

        uint256[] memory balances = new uint256[](3);
        balances[0] = 1 ether;
        balances[1] = 2 ether;
        balances[2] = 3 ether;
        bytes[] memory initialMPTLeaves = _createMPTLeaves(balances);
        bytes[] memory finalMPTLeaves = _createMPTLeaves(balances);

        vm.warp(block.timestamp + 1 days + 1);

        // Try to submit malicious proof with signature meant for legitimate proof
        (BridgeProofManager.ProofData memory maliciousProof,) =
            _createProofDataSimple(proofPart1, proofPart2, maliciousPublicInputs, 0, initialMPTLeaves, finalMPTLeaves);

        // Create signature for legitimate proof (different finalStateRoot)
        bytes32 legitimateCommitmentHash =
            keccak256(abi.encodePacked(channelId, bytes32(uint256(keccak256("legitimateStateRoot")))));
        BridgeProofManager.Signature memory legitimateSignature = BridgeProofManager.Signature({
            message: legitimateCommitmentHash,
            rx: 0x1fb4c0436e9054ae0b237cde3d7a478ce82405b43fdbb5bf1d63c9f8d912dd5d,
            ry: 0x3a7784df441925a8859b9f3baf8d570d488493506437db3ccf230a4b43b27c1e,
            z: 0xc7fdcb364dd8577e47dd479185ca659adbfcd1b8675e5cbb36e5f93ca4e15b25
        });

        // This should fail because signature doesn't match proof content
        vm.expectRevert("Signature must commit to proof content");
        proofManager.submitProofAndSignature(channelId, _wrapProofInArray(maliciousProof), legitimateSignature);

        // Verify channel state unchanged
        require(bridge.getChannelState(channelId) == BridgeCore.ChannelState.Open);
    }

    /**
     * @dev Helper to setup channel with specified number of participants
     */
    function _setupChannelWithParticipants(uint256 participantCount) internal returns (bytes32 channelId) {
        // Use different leaders to avoid "channel limit reached" error
        address channelLeader = address(uint160(100 + participantCount));

        // Fund the leader
        vm.deal(channelLeader, 10 ether);

        vm.startPrank(channelLeader);

        address[] memory participants = new address[](participantCount);
        for (uint256 i = 0; i < participantCount; i++) {
            participants[i] = address(uint160(3 + i)); // Start from address(3)
        }

        channelId = keccak256(abi.encode(address(this), participantCount, block.timestamp, "setupChannel"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });
        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        // Leader must deposit before initializing
        token.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(200 + participantCount)); // Unique L2 key for leader
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Deposit for each participant
        for (uint256 i = 0; i < participantCount; i++) {
            // Fund the participant
            vm.deal(participants[i], 10 ether);

            vm.startPrank(participants[i]);
            token.approve(address(depositManager), (i + 1) * 1 ether);
            bytes32[] memory mptKeys = new bytes32[](1);
            mptKeys[0] = bytes32(uint256(13 + i)); // Use different MPT keys
            depositManager.depositToken(channelId, (i + 1) * 1 ether, mptKeys);
            vm.stopPrank();
        }

        bytes32 mockMerkleRoot = keccak256(abi.encodePacked("mockRoot"));
        TestChannelInitializationProof memory mockProof = TestChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: mockMerkleRoot
        });
        vm.prank(channelLeader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: mockProof.pA,
                pB: mockProof.pB,
                pC: mockProof.pC,
                merkleRoot: mockProof.merkleRoot
            })
        );

        vm.stopPrank();
    }

    // ========== Tree Size Selection Tests ==========

    function testTreeSize128LeavesSelection() public {
        // Use a fresh leader for this test
        address testLeader = address(0x999);
        vm.deal(testLeader, 10 ether);
        vm.startPrank(testLeader);

        // Create 33 whitelisted users to force 64-leaf tree selection
        // 33 whitelisted users × 1 contract = 33 leaves, which requires 64-leaf tree
        address[] memory participants = new address[](33);
        for (uint256 i = 0; i < 33; i++) {
            participants[i] = address(uint160(1000 + i)); // Generate unique addresses
        }

        bytes32 testChannelId = keccak256(abi.encode(address(this), testLeader, "test64Leaves"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: testChannelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });

        // Open the channel
        bytes32 channelId = bridge.openChannel(params);
        assertEq(channelId, testChannelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );

        // Verify the channel was created successfully
        assertEq(channelId, testChannelId);

        // Get channel info to verify participants and target contract
        (address targetContract, BridgeCore.ChannelState state, uint256 participantCount,) =
            bridge.getChannelInfo(channelId);

        assertEq(targetContract, address(token));
        assertEq(uint8(state), uint8(BridgeCore.ChannelState.Initialized));
        assertEq(participantCount, 0); // No deposits made yet, so no actual participants

        // Verify that the contract selected the 64-leaf tree
        uint256 requiredTreeSize = bridge.getChannelTreeSize(channelId);
        assertEq(requiredTreeSize, 64, "Should select 64-leaf tree for 33 participants");

        vm.stopPrank();
    }

    function _wrapProofInArray(BridgeProofManager.ProofData memory proof)
        internal
        pure
        returns (BridgeProofManager.ProofData[] memory)
    {
        BridgeProofManager.ProofData[] memory proofs = new BridgeProofManager.ProofData[](1);
        proofs[0] = proof;
        return proofs;
    }

    function computeCorrectFunctionInstanceHash() internal pure returns (bytes32) {
        uint256[] memory functionInstances = new uint256[](446);

        functionInstances[0] = 0x01;
        functionInstances[1] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[2] = 0xffffffff;
        functionInstances[3] = 0xe72f6afd7d1f72623e6b071492d1122b;
        functionInstances[4] = 0x11dafe5d23e1218086a365b99fbf3d3b;
        functionInstances[5] = 0x3e26ba5cc220fed7cc3f870e59d292aa;
        functionInstances[6] = 0x1d523cf1ddab1a1793132e78c866c0c3;
        functionInstances[7] = 0x00;
        functionInstances[8] = 0x00;
        functionInstances[9] = 0x01;
        functionInstances[10] = 0x00;
        functionInstances[11] = 0x80;
        functionInstances[12] = 0x00;
        functionInstances[13] = 0x00;
        functionInstances[14] = 0x00;
        functionInstances[15] = 0x200000;
        functionInstances[16] = 0x04;
        functionInstances[17] = 0x00;
        functionInstances[18] = 0x44;
        functionInstances[19] = 0x00;
        functionInstances[20] = 0x010000;
        functionInstances[21] = 0xe0;
        functionInstances[22] = 0x00;
        functionInstances[23] = 0x08000000;
        functionInstances[24] = 0x20;
        functionInstances[25] = 0x00;
        functionInstances[26] = 0x10000000;
        functionInstances[27] = 0xe0;
        functionInstances[28] = 0x00;
        functionInstances[29] = 0x10000000;
        functionInstances[30] = 0x70a08231;
        functionInstances[31] = 0x00;
        functionInstances[32] = 0x020000;
        functionInstances[33] = 0x98650275;
        functionInstances[34] = 0x00;
        functionInstances[35] = 0x020000;
        functionInstances[36] = 0xaa271e1a;
        functionInstances[37] = 0x00;
        functionInstances[38] = 0x020000;
        functionInstances[39] = 0x98650275;
        functionInstances[40] = 0x00;
        functionInstances[41] = 0x100000;
        functionInstances[42] = 0xa457c2d7;
        functionInstances[43] = 0x00;
        functionInstances[44] = 0x100000;
        functionInstances[45] = 0xa9059cbb;
        functionInstances[46] = 0x00;
        functionInstances[47] = 0x100000;
        functionInstances[48] = 0x04;
        functionInstances[49] = 0x00;
        functionInstances[50] = 0x44;
        functionInstances[51] = 0x00;
        functionInstances[52] = 0x08;
        functionInstances[53] = 0x40;
        functionInstances[54] = 0x00;
        functionInstances[55] = 0x010000;
        functionInstances[56] = 0x200000;
        functionInstances[57] = 0x02;
        functionInstances[58] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[59] = 0xffffffff;
        functionInstances[60] = 0x20;
        functionInstances[61] = 0x00;
        functionInstances[62] = 0x02;
        functionInstances[63] = 0x20;
        functionInstances[64] = 0x00;
        functionInstances[65] = 0x02;
        functionInstances[66] = 0x00;
        functionInstances[67] = 0x00;
        functionInstances[68] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[69] = 0xffffffff;
        functionInstances[70] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[71] = 0xffffffff;
        functionInstances[72] = 0x100000;
        functionInstances[73] = 0x200000;
        functionInstances[74] = 0x00;
        functionInstances[75] = 0x00;
        functionInstances[76] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[77] = 0xffffffff;
        functionInstances[78] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[79] = 0xffffffff;
        functionInstances[80] = 0x100000;
        functionInstances[81] = 0x200000;
        functionInstances[82] = 0x60;
        functionInstances[83] = 0x00;
        functionInstances[84] = 0x02;
        functionInstances[85] = 0x20;
        functionInstances[86] = 0x00;
        functionInstances[87] = 0x02;
        functionInstances[88] = 0x00;
        functionInstances[89] = 0x00;
        functionInstances[90] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[91] = 0xffffffff;
        functionInstances[92] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[93] = 0xffffffff;
        functionInstances[94] = 0x20;
        functionInstances[95] = 0x00;
        functionInstances[96] = 0x02;
        functionInstances[97] = 0x20;
        functionInstances[98] = 0x00;
        functionInstances[99] = 0x02;
        functionInstances[100] = 0x1da9;
        functionInstances[101] = 0x00;
        functionInstances[102] = 0xffffffff;
        functionInstances[103] = 0x00;
        functionInstances[104] = 0x020000;
        functionInstances[105] = 0x200000;
        functionInstances[106] = 0x08;
        functionInstances[107] = 0x00;
        functionInstances[108] = 0x00;
        functionInstances[109] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[110] = 0xffffffff;
        functionInstances[111] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[112] = 0xffffffff;
        functionInstances[113] = 0x20;
        functionInstances[114] = 0x00;
        functionInstances[115] = 0x02;
        functionInstances[116] = 0x20;
        functionInstances[117] = 0x00;
        functionInstances[118] = 0x02;
        functionInstances[119] = 0x00;
        functionInstances[120] = 0x00;
        functionInstances[121] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[122] = 0xffffffff;
        functionInstances[123] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[124] = 0xffffffff;
        functionInstances[125] = 0x20;
        functionInstances[126] = 0x00;
        functionInstances[127] = 0x02;
        functionInstances[128] = 0x20;
        functionInstances[129] = 0x00;
        functionInstances[130] = 0x02;
        functionInstances[131] = 0x1acc;
        functionInstances[132] = 0x00;
        functionInstances[133] = 0xffffffff;
        functionInstances[134] = 0x00;
        functionInstances[135] = 0x02;
        functionInstances[136] = 0x010000;
        functionInstances[137] = 0x200000;
        functionInstances[138] = 0x00;
        functionInstances[139] = 0x00;
        functionInstances[140] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[141] = 0xffffffff;
        functionInstances[142] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[143] = 0xffffffff;
        functionInstances[144] = 0x20;
        functionInstances[145] = 0x00;
        functionInstances[146] = 0x02;
        functionInstances[147] = 0x20;
        functionInstances[148] = 0x00;
        functionInstances[149] = 0x02;
        functionInstances[150] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[151] = 0xffffffff;
        functionInstances[152] = 0xffffffffffffffffffffffffffffffff;
        functionInstances[153] = 0xffffffff;
        functionInstances[154] = 0x20;
        functionInstances[155] = 0x00;
        functionInstances[156] = 0x02;
        functionInstances[157] = 0x08;
        functionInstances[158] = 0x07;
        functionInstances[159] = 0x00;
        functionInstances[160] = 0x15;
        functionInstances[161] = 0x00;
        functionInstances[162] = 0x0100;
        functionInstances[163] = 0x00;
        functionInstances[164] = 0x01;
        functionInstances[165] = 0x00;
        functionInstances[166] = 0x10;
        functionInstances[167] = 0xff;
        functionInstances[168] = 0x00;
        functionInstances[169] = 0x200000;
        functionInstances[170] = 0x200000;
        functionInstances[171] = 0x01;
        functionInstances[172] = 0x00;
        functionInstances[173] = 0x200000;
        functionInstances[174] = 0x200000;
        functionInstances[175] = 0x200000;
        functionInstances[176] = 0x200000;
        functionInstances[177] = 0x20;
        functionInstances[178] = 0x00;
        functionInstances[179] = 0x02;
        functionInstances[180] = 0x08;
        // Rest are zeros (181-445)

        return keccak256(abi.encodePacked(functionInstances));
    }
}



================================================
FILE: test/bridge/ChannelIdTest.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/IBridgeCore.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title ChannelIdTest
 * @notice Test the new bytes32 channelId system
 */
contract ChannelIdTest is Test {
    BridgeCore bridgeCore;
    BridgeAdminManager adminManager;

    address constant TARGET_CONTRACT = address(0x123456);
    address constant USER1 = address(0x1001);
    address constant USER2 = address(0x1002);

    function setUp() public {
        bridgeCore = new BridgeCore();
        adminManager = new BridgeAdminManager();

        ERC1967Proxy bridgeCoreProxy = new ERC1967Proxy(
            address(bridgeCore),
            abi.encodeCall(
                bridgeCore.initialize, (address(0), address(0), address(0), address(adminManager), address(this))
            )
        );
        bridgeCore = BridgeCore(address(bridgeCoreProxy));

        ERC1967Proxy adminManagerProxy = new ERC1967Proxy(
            address(adminManager), abi.encodeCall(adminManager.initialize, (address(bridgeCore), address(this)))
        );
        adminManager = BridgeAdminManager(address(adminManagerProxy));

        bridgeCore.updateManagerAddresses(address(0), address(0), address(0), address(adminManager));

        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(TARGET_CONTRACT, emptySlots, balanceSlot, true);
    }

    function testNewChannelIdSystem() public {
        // Generate a channel ID
        bytes32 salt = bytes32(uint256(12345));
        bytes32 channelId = bridgeCore.generateChannelId(address(this), salt);

        assertNotEq(channelId, bytes32(0), "Channel ID should not be zero");

        // Create channel with generated ID
        address[] memory participants = new address[](2);
        participants[0] = USER1;
        participants[1] = USER2;

        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: TARGET_CONTRACT,
            whitelisted: participants,
            enableFrostSignature: false
        });

        bytes32 returnedChannelId = bridgeCore.openChannel(params);
        assertEq(returnedChannelId, channelId, "Returned channel ID should match input");

        // Verify channel exists
        BridgeCore.ChannelState state = bridgeCore.getChannelState(channelId);
        assertEq(uint256(state), uint256(BridgeCore.ChannelState.Initialized), "Channel should be initialized");

        address leader = bridgeCore.getChannelLeader(channelId);
        assertEq(leader, address(this), "Channel leader should be correct");
    }

    function testDuplicateChannelId() public {
        bytes32 channelId = keccak256("test-channel");

        address[] memory participants = new address[](2);
        participants[0] = USER1;
        participants[1] = USER2;

        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: TARGET_CONTRACT,
            whitelisted: participants,
            enableFrostSignature: false
        });

        // First call should succeed
        bridgeCore.openChannel(params);

        // Second call with same ID should fail
        vm.expectRevert("Channel ID already exists");
        bridgeCore.openChannel(params);
    }

    function testZeroChannelId() public {
        address[] memory participants = new address[](2);
        participants[0] = USER1;
        participants[1] = USER2;

        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: bytes32(0),
            targetContract: TARGET_CONTRACT,
            whitelisted: participants,
            enableFrostSignature: false
        });

        vm.expectRevert("Channel ID cannot be zero");
        bridgeCore.openChannel(params);
    }

    function testGenerateChannelId() public view {
        address leader = address(0x123);
        bytes32 salt1 = bytes32(uint256(1));
        bytes32 salt2 = bytes32(uint256(2));

        bytes32 id1 = bridgeCore.generateChannelId(leader, salt1);
        bytes32 id2 = bridgeCore.generateChannelId(leader, salt2);

        // Different salts should produce different IDs
        assertNotEq(id1, id2, "Different salts should produce different channel IDs");

        // Same inputs should produce same ID
        bytes32 id3 = bridgeCore.generateChannelId(leader, salt1);
        assertEq(id1, id3, "Same inputs should produce same channel ID");
    }
}



================================================
FILE: test/bridge/ModularArchitectureTest.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/BridgeDepositManager.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/ITokamakVerifier.sol";
import "../../src/interface/IZecFrost.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import "../../src/library/ZecFrost.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

// Mock contracts for testing
contract MockTokamakVerifier is ITokamakVerifier {
    function verify(
        uint128[] calldata,
        uint256[] calldata,
        uint128[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        uint256
    ) external pure returns (bool) {
        return true;
    }
}

contract MockGroth16Verifier is IGroth16Verifier16Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[33] calldata)
        external
        pure
        returns (bool)
    {
        return true;
    }
}

contract TestToken is ERC20 {
    constructor() ERC20("Test Token", "TEST") {
        _mint(msg.sender, 1000000 ether);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @title ModularArchitectureTest
 * @notice Test that demonstrates the working modular architecture
 */
contract ModularArchitectureTest is Test {
    BridgeCore public bridge;
    BridgeProofManager public proofManager;
    BridgeDepositManager public depositManager;
    BridgeAdminManager public adminManager;

    MockTokamakVerifier public tokamakVerifier;
    MockGroth16Verifier public groth16Verifier;
    ZecFrost public zecFrost;
    TestToken public testToken;

    address public owner = makeAddr("owner");
    address public leader = makeAddr("leader");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");

    function setUp() public {
        vm.startPrank(owner);

        // Deploy mock contracts
        tokamakVerifier = new MockTokamakVerifier();
        groth16Verifier = new MockGroth16Verifier();
        zecFrost = new ZecFrost();
        testToken = new TestToken();

        // Deploy manager implementations
        BridgeDepositManager depositManagerImpl = new BridgeDepositManager();
        BridgeProofManager proofManagerImpl = new BridgeProofManager();
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();

        // Deploy core contract with proxy first
        BridgeCore implementation = new BridgeCore();
        bytes memory bridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(0), address(0), address(0), address(0), owner) // Temporary addresses
        );
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(implementation), bridgeInitData);
        bridge = BridgeCore(address(bridgeProxy));

        // Deploy manager proxies with bridge address
        bytes memory depositInitData = abi.encodeCall(BridgeDepositManager.initialize, (address(bridge), owner));
        ERC1967Proxy depositProxy = new ERC1967Proxy(address(depositManagerImpl), depositInitData);
        depositManager = BridgeDepositManager(address(depositProxy));

        address[4] memory groth16Verifiers =
            [address(groth16Verifier), address(groth16Verifier), address(groth16Verifier), address(groth16Verifier)];
        bytes memory proofInitData = abi.encodeCall(
            BridgeProofManager.initialize,
            (address(bridge), address(tokamakVerifier), address(zecFrost), groth16Verifiers, owner)
        );
        ERC1967Proxy proofProxy = new ERC1967Proxy(address(proofManagerImpl), proofInitData);
        proofManager = BridgeProofManager(address(proofProxy));

        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        // Update bridge with manager addresses
        bridge.updateManagerAddresses(address(depositManager), address(proofManager), address(0), address(adminManager));

        // Register the test token and its transfer function
        uint128[] memory preprocessedPart1 = new uint128[](4);
        uint256[] memory preprocessedPart2 = new uint256[](4);
        bytes32 transferSig = keccak256("transfer(address,uint256)");

        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);
        adminManager.registerFunction(
            address(testToken), transferSig, preprocessedPart1, preprocessedPart2, keccak256("test_instance_hash")
        );

        // Fund test accounts
        vm.deal(leader, 10 ether);
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);
        vm.deal(user3, 10 ether);

        // Mint test tokens for users and leader
        testToken.mint(user1, 1000 ether);
        testToken.mint(user2, 1000 ether);
        testToken.mint(user3, 1000 ether);
        testToken.mint(leader, 1000 ether);

        vm.stopPrank();
    }

    function testModularArchitectureBasic() public view {
        // Test that all contracts are properly deployed
        assertEq(bridge.owner(), owner);
        assertEq(depositManager.owner(), owner);
        assertEq(proofManager.owner(), owner);

        // Test that managers are properly linked
        assertEq(address(depositManager.bridge()), address(bridge));
        assertEq(address(proofManager.bridge()), address(bridge));
    }

    function testGetImplementationAddress() public view {
        // Test that getImplementation() returns the correct implementation addresses
        address bridgeImpl = bridge.getImplementation();
        address depositImpl = depositManager.getImplementation();
        address proofImpl = proofManager.getImplementation();

        // Verify that implementation addresses are not zero and not the proxy addresses
        assertTrue(bridgeImpl != address(0), "Bridge implementation should not be zero");
        assertTrue(depositImpl != address(0), "Deposit manager implementation should not be zero");
        assertTrue(proofImpl != address(0), "Proof manager implementation should not be zero");

        assertTrue(bridgeImpl != address(bridge), "Implementation should not equal proxy address");
        assertTrue(depositImpl != address(depositManager), "Implementation should not equal proxy address");
        assertTrue(proofImpl != address(proofManager), "Implementation should not equal proxy address");

        console.log("Bridge proxy:", address(bridge));
        console.log("Bridge implementation:", bridgeImpl);
        console.log("Deposit manager proxy:", address(depositManager));
        console.log("Deposit manager implementation:", depositImpl);
        console.log("Proof manager proxy:", address(proofManager));
        console.log("Proof manager implementation:", proofImpl);
    }

    function testChannelCreationAndDeposits() public {
        // Create a channel
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "testBasicChannelOperations"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(testToken),
            whitelisted: participants,
            enableFrostSignature: true
        });

        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(channelId, 1, 2);
        vm.stopPrank();

        // Verify channel creation
        assertEq(returnedChannelId, channelId);
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(BridgeCore.ChannelState.Initialized));
        assertEq(bridge.getChannelTargetContract(channelId), address(testToken));

        // Test deposit using DepositManager
        vm.startPrank(user1);
        testToken.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(uint256(123));
        depositManager.depositToken(channelId, 1 ether, mptKeys);
        vm.stopPrank();

        // Verify deposit was recorded
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 1 ether);
        assertEq(bridge.getL2MptKey(channelId, user1, 0), 123);
    }

    function testChannelStateInitialization() public {
        // Create and deposit to a channel
        bytes32 channelId = _createChannelWithDeposits();

        // Get the actual leader who created the channel
        address actualLeader = bridge.getChannelLeader(channelId);

        // Initialize channel state using ProofManager (leader is the channel creator)
        vm.roll(30); // Set block number high enough to avoid underflow in block.number - 3
        vm.startPrank(actualLeader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
                pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
                pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
                merkleRoot: keccak256(abi.encodePacked("mockRoot"))
            })
        );
        vm.stopPrank();

        // Verify state transition
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(BridgeCore.ChannelState.Open));
    }

    function _createChannelWithDeposits() internal returns (bytes32 channelId) {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        channelId = keccak256(abi.encode(address(this), block.timestamp, "createChannelWithDeposits"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(testToken),
            whitelisted: participants,
            enableFrostSignature: true
        });

        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(channelId, 1, 2);

        // Leader must deposit before initializing
        testToken.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(999));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Add deposits
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(uint256(123));
        vm.startPrank(user1);
        testToken.approve(address(depositManager), 1 ether);
        depositManager.depositToken(channelId, 1 ether, mptKeys1);
        vm.stopPrank();

        bytes32[] memory mptKeys2 = new bytes32[](1);
        mptKeys2[0] = bytes32(uint256(456));
        vm.startPrank(user2);
        testToken.approve(address(depositManager), 2 ether);
        depositManager.depositToken(channelId, 2 ether, mptKeys2);
        vm.stopPrank();

        bytes32[] memory mptKeys3 = new bytes32[](1);
        mptKeys3[0] = bytes32(uint256(789));
        vm.startPrank(user3);
        testToken.approve(address(depositManager), 3 ether);
        depositManager.depositToken(channelId, 3 ether, mptKeys3);
        vm.stopPrank();
    }

    function testChannelWithoutFrostSignature() public {
        vm.prank(leader);
        address[] memory participants = new address[](2);
        participants[0] = user1;
        participants[1] = user2;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "testDisableFrostSignature"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(testToken),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);

        // Verify frost signature is disabled for this channel
        assertFalse(bridge.isFrostSignatureEnabled(channelId));

        // Verify channel was created successfully
        assertTrue(bridge.isChannelWhitelisted(channelId, user1));
        assertTrue(bridge.isChannelWhitelisted(channelId, user2));
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Initialized));

        // Test that deposit works without setting public key
        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(uint256(123));
        vm.startPrank(user1);
        testToken.approve(address(depositManager), 1 ether);
        depositManager.depositToken(channelId, 1 ether, mptKeys);
        vm.stopPrank();

        // Verify deposit was recorded
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 1 ether);
        assertEq(bridge.getL2MptKey(channelId, user1, 0), 123);
    }
}



================================================
FILE: test/bridge/MptKeysAndPubSignals.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/BridgeDepositManager.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/ITokamakVerifier.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import "../../src/library/ZecFrost.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

// Simple ERC20 token (no additional storage slots)
contract SimpleToken is ERC20 {
    constructor() ERC20("Simple Token", "SIMPLE") {
        _mint(msg.sender, 1000000 ether);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// USDT-like token with blacklist functionality (1 additional storage slot)
contract USDTToken is ERC20 {
    mapping(address => bool) private _isBlackListed;

    constructor() ERC20("Mock USDT", "USDT") {
        _mint(msg.sender, 1000000 ether);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function addBlackList(address user) external {
        _isBlackListed[user] = true;
    }

    function removeBlackList(address user) external {
        _isBlackListed[user] = false;
    }

    function isBlackListed(address user) external view returns (bool) {
        return _isBlackListed[user];
    }
}

contract MockTokamakVerifier is ITokamakVerifier {
    function verify(uint128[] calldata, uint256[] calldata, uint128[] calldata, uint256[] calldata, uint256[] calldata, uint256)
        external
        pure
        returns (bool)
    {
        return true;
    }
}

contract MockGroth16Verifier is IGroth16Verifier16Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[33] calldata)
        external
        pure
        returns (bool)
    {
        return true;
    }
}

/**
 * @title MptKeysAndPubSignalsTest
 * @notice Tests for MPT keys storage and pubSignals array construction in initializeChannelState
 */
contract MptKeysAndPubSignalsTest is Test {
    BridgeCore public bridge;
    BridgeProofManager public proofManager;
    BridgeDepositManager public depositManager;
    BridgeAdminManager public adminManager;

    MockTokamakVerifier public tokamakVerifier;
    MockGroth16Verifier public groth16Verifier;
    ZecFrost public zecFrost;
    SimpleToken public simpleToken;
    USDTToken public usdtToken;

    address public owner = makeAddr("owner");
    address public leader = makeAddr("leader");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");

    // MPT keys for testing
    uint256 constant USER1_BALANCE_MPT_KEY = 1001;
    uint256 constant USER1_BLACKLIST_MPT_KEY = 2001;
    uint256 constant USER2_BALANCE_MPT_KEY = 1002;
    uint256 constant USER2_BLACKLIST_MPT_KEY = 2002;
    uint256 constant USER3_BALANCE_MPT_KEY = 1003;
    uint256 constant USER3_BLACKLIST_MPT_KEY = 2003;

    function setUp() public {
        vm.roll(100); // Set block number to avoid underflow

        vm.startPrank(owner);

        // Deploy mock contracts
        tokamakVerifier = new MockTokamakVerifier();
        groth16Verifier = new MockGroth16Verifier();
        zecFrost = new ZecFrost();
        simpleToken = new SimpleToken();
        usdtToken = new USDTToken();

        // Deploy manager implementations
        BridgeDepositManager depositManagerImpl = new BridgeDepositManager();
        BridgeProofManager proofManagerImpl = new BridgeProofManager();
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();

        // Deploy core contract with proxy
        BridgeCore implementation = new BridgeCore();
        bytes memory bridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(0), address(0), address(0), address(0), owner)
        );
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(implementation), bridgeInitData);
        bridge = BridgeCore(address(bridgeProxy));

        // Deploy manager proxies
        bytes memory depositInitData = abi.encodeCall(BridgeDepositManager.initialize, (address(bridge), owner));
        ERC1967Proxy depositProxy = new ERC1967Proxy(address(depositManagerImpl), depositInitData);
        depositManager = BridgeDepositManager(address(depositProxy));

        address[4] memory groth16Verifiers = [
            address(groth16Verifier),
            address(groth16Verifier),
            address(groth16Verifier),
            address(groth16Verifier)
        ];
        bytes memory proofInitData = abi.encodeCall(
            BridgeProofManager.initialize,
            (address(bridge), address(tokamakVerifier), address(zecFrost), groth16Verifiers, owner)
        );
        ERC1967Proxy proofProxy = new ERC1967Proxy(address(proofManagerImpl), proofInitData);
        proofManager = BridgeProofManager(address(proofProxy));

        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        // Update manager addresses
        bridge.updateManagerAddresses(
            address(depositManager), address(proofManager), address(0), address(adminManager)
        );

        // Register simple token with balance slot only
        IBridgeCore.PreAllocatedLeaf[] memory emptyLeaves = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory simpleSlots = new IBridgeCore.UserStorageSlot[](1);
        simpleSlots[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0, // balance slot
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false // balance comes from deposits
        });
        adminManager.setAllowedTargetContract(address(simpleToken), emptyLeaves, simpleSlots, true);

        // Register USDT token with balance + isBlackListed storage slots
        IBridgeCore.UserStorageSlot[] memory usdtSlots = new IBridgeCore.UserStorageSlot[](2);
        usdtSlots[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 2, // USDT balance slot
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false // balance comes from deposits
        });
        usdtSlots[1] = IBridgeCore.UserStorageSlot({
            slotOffset: 6, // USDT isBlackListed slot
            getterFunctionSignature: bytes32(bytes4(keccak256("isBlackListed(address)"))),
            isLoadedOnChain: true // fetched from chain
        });
        adminManager.setAllowedTargetContract(address(usdtToken), emptyLeaves, usdtSlots, true);

        // Mint tokens to participants and leader
        simpleToken.mint(user1, 100 ether);
        simpleToken.mint(user2, 100 ether);
        simpleToken.mint(user3, 100 ether);
        simpleToken.mint(leader, 100 ether);
        usdtToken.mint(user1, 100 ether);
        usdtToken.mint(user2, 100 ether);
        usdtToken.mint(user3, 100 ether);
        usdtToken.mint(leader, 100 ether);

        vm.stopPrank();
    }

    // ========== MPT KEYS STORAGE TESTS ==========

    function testMptKeysStoredCorrectlyForSimpleToken() public {
        bytes32 channelId = _createSimpleTokenChannel();

        // User1 deposits with 1 MPT key (balance only)
        vm.startPrank(user1);
        simpleToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys = new bytes32[](1);
        mptKeys[0] = bytes32(USER1_BALANCE_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys);
        vm.stopPrank();

        // Verify MPT key stored correctly at slot 0
        uint256 storedKey = bridge.getL2MptKey(channelId, user1, 0);
        assertEq(storedKey, USER1_BALANCE_MPT_KEY, "Balance MPT key not stored correctly");
    }

    function testMptKeysStoredCorrectlyForUSDTToken() public {
        bytes32 channelId = _createUSDTChannel();

        // User1 deposits with 2 MPT keys (balance + isBlackListed)
        vm.startPrank(user1);
        usdtToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys = new bytes32[](2);
        mptKeys[0] = bytes32(USER1_BALANCE_MPT_KEY);
        mptKeys[1] = bytes32(USER1_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys);
        vm.stopPrank();

        // Verify MPT keys stored correctly at respective slots
        uint256 balanceKey = bridge.getL2MptKey(channelId, user1, 0);
        uint256 blacklistKey = bridge.getL2MptKey(channelId, user1, 1);

        assertEq(balanceKey, USER1_BALANCE_MPT_KEY, "Balance MPT key not stored correctly");
        assertEq(blacklistKey, USER1_BLACKLIST_MPT_KEY, "Blacklist MPT key not stored correctly");
    }

    function testMptKeysStoredCorrectlyForMultipleUsers() public {
        bytes32 channelId = _createUSDTChannel();

        // User1 deposits
        vm.startPrank(user1);
        usdtToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](2);
        mptKeys1[0] = bytes32(USER1_BALANCE_MPT_KEY);
        mptKeys1[1] = bytes32(USER1_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        // User2 deposits
        vm.startPrank(user2);
        usdtToken.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](2);
        mptKeys2[0] = bytes32(USER2_BALANCE_MPT_KEY);
        mptKeys2[1] = bytes32(USER2_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        // User3 deposits
        vm.startPrank(user3);
        usdtToken.approve(address(depositManager), 15 ether);
        bytes32[] memory mptKeys3 = new bytes32[](2);
        mptKeys3[0] = bytes32(USER3_BALANCE_MPT_KEY);
        mptKeys3[1] = bytes32(USER3_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 15 ether, mptKeys3);
        vm.stopPrank();

        // Verify all MPT keys stored correctly
        assertEq(bridge.getL2MptKey(channelId, user1, 0), USER1_BALANCE_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user1, 1), USER1_BLACKLIST_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user2, 0), USER2_BALANCE_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user2, 1), USER2_BLACKLIST_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user3, 0), USER3_BALANCE_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user3, 1), USER3_BLACKLIST_MPT_KEY);
    }

    function testMptKeysCountMismatchReverts() public {
        bytes32 channelId = _createUSDTChannel();

        // Try to deposit with wrong number of MPT keys (1 instead of 2)
        vm.startPrank(user1);
        usdtToken.approve(address(depositManager), 10 ether);
        bytes32[] memory wrongMptKeys = new bytes32[](1);
        wrongMptKeys[0] = bytes32(USER1_BALANCE_MPT_KEY);

        vm.expectRevert("MPT keys count mismatch");
        depositManager.depositToken(channelId, 10 ether, wrongMptKeys);
        vm.stopPrank();
    }

    function testMptKeysTooManyReverts() public {
        bytes32 channelId = _createSimpleTokenChannel();

        // Try to deposit with too many MPT keys (2 instead of 1)
        vm.startPrank(user1);
        simpleToken.approve(address(depositManager), 10 ether);
        bytes32[] memory wrongMptKeys = new bytes32[](2);
        wrongMptKeys[0] = bytes32(USER1_BALANCE_MPT_KEY);
        wrongMptKeys[1] = bytes32(USER1_BLACKLIST_MPT_KEY);

        vm.expectRevert("MPT keys count mismatch");
        depositManager.depositToken(channelId, 10 ether, wrongMptKeys);
        vm.stopPrank();
    }

    // ========== PUBSIGNALS INPUT DATA VERIFICATION TESTS ==========
    // These tests verify that all the data that goes into pubSignals construction is correct

    function testPubSignalsInputsForSimpleToken() public {
        bytes32 channelId = _createSimpleTokenChannel();

        // Leader must deposit before initializing
        vm.startPrank(leader);
        simpleToken.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(999));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // User1 deposits 10 ether
        vm.startPrank(user1);
        simpleToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(USER1_BALANCE_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        // User2 deposits 20 ether
        vm.startPrank(user2);
        simpleToken.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](1);
        mptKeys2[0] = bytes32(USER2_BALANCE_MPT_KEY);
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        // Verify all inputs that go into pubSignals are correct
        address[] memory participants = bridge.getChannelParticipants(channelId);
        assertEq(participants.length, 3, "Should have 3 participants (leader + 2 users)");
        assertEq(participants[0], leader);
        assertEq(participants[1], user1);
        assertEq(participants[2], user2);

        // Verify balances
        assertEq(bridge.getValidatedUserSlotValue(channelId, leader, 0), 1 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 10 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user2, 0), 20 ether);

        // Verify MPT keys for balance slot (slot 0)
        assertEq(bridge.getL2MptKey(channelId, user1, 0), USER1_BALANCE_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user2, 0), USER2_BALANCE_MPT_KEY);

        // Verify tree size
        assertEq(bridge.getChannelTreeSize(channelId), 16);

        // Initialize channel to verify the proof manager accepts the data
        bytes32 merkleRoot = keccak256("testMerkleRoot");
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
                pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
                pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
                merkleRoot: merkleRoot
            })
        );

        // Verify channel state changed to Open (proves initialization succeeded)
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Open));
    }

    function testPubSignalsInputsForUSDTToken() public {
        bytes32 channelId = _createUSDTChannel();

        // Leader must deposit before initializing
        vm.startPrank(leader);
        usdtToken.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](2);
        mptKeysLeader[0] = bytes32(uint256(998));
        mptKeysLeader[1] = bytes32(uint256(999));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // User1 deposits 10 ether (will not be blacklisted)
        vm.startPrank(user1);
        usdtToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](2);
        mptKeys1[0] = bytes32(USER1_BALANCE_MPT_KEY);
        mptKeys1[1] = bytes32(USER1_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        // User2 deposits 20 ether (will be blacklisted after deposit)
        vm.startPrank(user2);
        usdtToken.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](2);
        mptKeys2[0] = bytes32(USER2_BALANCE_MPT_KEY);
        mptKeys2[1] = bytes32(USER2_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        // Blacklist user2 AFTER deposit
        vm.prank(owner);
        usdtToken.addBlackList(user2);

        // Verify all inputs that go into pubSignals
        address[] memory participants = bridge.getChannelParticipants(channelId);
        assertEq(participants.length, 3, "Should have 3 participants (leader + 2 users)");
        assertEq(participants[0], leader);
        assertEq(participants[1], user1);
        assertEq(participants[2], user2);

        // Verify balances
        assertEq(bridge.getValidatedUserSlotValue(channelId, leader, 0), 1 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 10 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user2, 0), 20 ether);

        // Verify MPT keys for balance slot (slot 0)
        assertEq(bridge.getL2MptKey(channelId, user1, 0), USER1_BALANCE_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user2, 0), USER2_BALANCE_MPT_KEY);

        // Verify MPT keys for blacklist slot (slot 1)
        assertEq(bridge.getL2MptKey(channelId, user1, 1), USER1_BLACKLIST_MPT_KEY);
        assertEq(bridge.getL2MptKey(channelId, user2, 1), USER2_BLACKLIST_MPT_KEY);

        // Verify blacklist status (will be fetched via staticcall during initialization)
        assertFalse(usdtToken.isBlackListed(user1), "user1 should not be blacklisted");
        assertTrue(usdtToken.isBlackListed(user2), "user2 should be blacklisted");

        // Verify tree size (3 participants * 2 slots = 6 leaves, fits in tree size 16)
        assertEq(bridge.getChannelTreeSize(channelId), 16);

        // Initialize channel to verify the proof manager accepts the data
        bytes32 merkleRoot = keccak256("testMerkleRoot");
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
                pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
                pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
                merkleRoot: merkleRoot
            })
        );

        // Verify channel state changed to Open
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Open));
    }

    function testPubSignalsConstructionLogic() public {
        bytes32 channelId = _createUSDTChannel();

        // Leader must deposit before initializing
        vm.startPrank(leader);
        usdtToken.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](2);
        mptKeysLeader[0] = bytes32(uint256(998));
        mptKeysLeader[1] = bytes32(uint256(999));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Setup: 3 users deposit with specific MPT keys and amounts
        vm.startPrank(user1);
        usdtToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](2);
        mptKeys1[0] = bytes32(USER1_BALANCE_MPT_KEY);
        mptKeys1[1] = bytes32(USER1_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        usdtToken.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](2);
        mptKeys2[0] = bytes32(USER2_BALANCE_MPT_KEY);
        mptKeys2[1] = bytes32(USER2_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        vm.startPrank(user3);
        usdtToken.approve(address(depositManager), 15 ether);
        bytes32[] memory mptKeys3 = new bytes32[](2);
        mptKeys3[0] = bytes32(USER3_BALANCE_MPT_KEY);
        mptKeys3[1] = bytes32(USER3_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 15 ether, mptKeys3);
        vm.stopPrank();

        // Blacklist user3
        vm.prank(owner);
        usdtToken.addBlackList(user3);

        // Manually construct what pubSignals SHOULD look like
        // Based on initializeChannelState logic:
        // pubSignals[0] = merkleRoot
        // For treeSize=16:
        //   Indices 1-16: keys
        //   Indices 17-32: values
        // Order: ALL balance leaves first, then ALL blacklist leaves

        uint256 treeSize = bridge.getChannelTreeSize(channelId);
        assertEq(treeSize, 16, "Tree size should be 16");

        address[] memory participants = bridge.getChannelParticipants(channelId);
        assertEq(participants.length, 4, "Should have 4 participants (leader + 3 users)");
        assertEq(participants[0], leader, "First participant should be leader");
        assertEq(participants[1], user1, "Second participant should be user1");
        assertEq(participants[2], user2, "Third participant should be user2");
        assertEq(participants[3], user3, "Fourth participant should be user3");

        // Verify balances for users (not checking leader's MPT key as it uses different constant)
        assertEq(bridge.getL2MptKey(channelId, user1, 0), USER1_BALANCE_MPT_KEY, "user1 balance key");
        assertEq(bridge.getL2MptKey(channelId, user2, 0), USER2_BALANCE_MPT_KEY, "user2 balance key");
        assertEq(bridge.getL2MptKey(channelId, user3, 0), USER3_BALANCE_MPT_KEY, "user3 balance key");
        assertEq(bridge.getL2MptKey(channelId, user1, 1), USER1_BLACKLIST_MPT_KEY, "user1 blacklist key");
        assertEq(bridge.getL2MptKey(channelId, user2, 1), USER2_BLACKLIST_MPT_KEY, "user2 blacklist key");
        assertEq(bridge.getL2MptKey(channelId, user3, 1), USER3_BLACKLIST_MPT_KEY, "user3 blacklist key");

        assertEq(bridge.getValidatedUserSlotValue(channelId, leader, 0), 1 ether, "leader balance");
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 10 ether, "user1 balance");
        assertEq(bridge.getValidatedUserSlotValue(channelId, user2, 0), 20 ether, "user2 balance");
        assertEq(bridge.getValidatedUserSlotValue(channelId, user3, 0), 15 ether, "user3 balance");
        assertEq(usdtToken.isBlackListed(leader) ? 1 : 0, 0, "leader not blacklisted");
        assertEq(usdtToken.isBlackListed(user1) ? 1 : 0, 0, "user1 not blacklisted");
        assertEq(usdtToken.isBlackListed(user2) ? 1 : 0, 0, "user2 not blacklisted");
        assertEq(usdtToken.isBlackListed(user3) ? 1 : 0, 1, "user3 is blacklisted");

        // Initialize channel to confirm the proof manager constructs pubSignals correctly
        bytes32 merkleRoot = keccak256("testMerkleRoot");
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
                pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
                pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
                merkleRoot: merkleRoot
            })
        );

        // Channel initialization succeeded
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Open));
    }

    function testPubSignalsOrderingIsCorrect() public {
        // This test verifies the ordering: ALL balance leaves first, then ALL additional storage slot leaves
        bytes32 channelId = _createUSDTChannel();

        // Leader must deposit before initializing
        vm.startPrank(leader);
        usdtToken.approve(address(depositManager), 1 ether);
        bytes32[] memory mptKeysLeader = new bytes32[](2);
        mptKeysLeader[0] = bytes32(uint256(998));
        mptKeysLeader[1] = bytes32(uint256(999));
        depositManager.depositToken(channelId, 1 ether, mptKeysLeader);
        vm.stopPrank();

        // Deposit for all 3 users
        vm.startPrank(user1);
        usdtToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](2);
        mptKeys1[0] = bytes32(USER1_BALANCE_MPT_KEY);
        mptKeys1[1] = bytes32(USER1_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        usdtToken.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](2);
        mptKeys2[0] = bytes32(USER2_BALANCE_MPT_KEY);
        mptKeys2[1] = bytes32(USER2_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        vm.startPrank(user3);
        usdtToken.approve(address(depositManager), 15 ether);
        bytes32[] memory mptKeys3 = new bytes32[](2);
        mptKeys3[0] = bytes32(USER3_BALANCE_MPT_KEY);
        mptKeys3[1] = bytes32(USER3_BLACKLIST_MPT_KEY);
        depositManager.depositToken(channelId, 15 ether, mptKeys3);
        vm.stopPrank();

        // Get participants to verify ordering
        address[] memory participants = bridge.getChannelParticipants(channelId);

        // The pubSignals should be ordered as:
        // [0]: merkleRoot
        // [1]: participants[0] balance key (leader)
        // [2]: participants[1] balance key (user1)
        // [3]: participants[2] balance key (user2)
        // [4]: participants[3] balance key (user3)
        // [5]: participants[0] blacklist key (leader)
        // [6]: participants[1] blacklist key (user1)
        // [7]: participants[2] blacklist key (user2)
        // [8]: participants[3] blacklist key (user3)
        // ... zeros until treeSize
        // [treeSize+1]: participants[0] balance value
        // etc.

        // Verify participants are in expected order (leader first, then users)
        assertEq(participants.length, 4, "Should have 4 participants");
        assertEq(participants[0], leader);
        assertEq(participants[1], user1);
        assertEq(participants[2], user2);
        assertEq(participants[3], user3);

        // Initialize to confirm the construction works
        vm.prank(leader);
        proofManager.initializeChannelState(
            channelId,
            BridgeProofManager.ChannelInitializationProof({
                pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
                pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
                pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
                merkleRoot: keccak256("testRoot")
            })
        );

        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Open));
    }

    // ========== HELPER FUNCTIONS ==========

    function _createSimpleTokenChannel() internal returns (bytes32 channelId) {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        channelId = keccak256(abi.encode(address(this), block.timestamp, "simpleTokenChannel"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(simpleToken),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bridge.openChannel(params);
        vm.stopPrank();
    }

    function _createUSDTChannel() internal returns (bytes32 channelId) {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        channelId = keccak256(abi.encode(address(this), block.timestamp, "usdtChannel"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(usdtToken),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bridge.openChannel(params);
        vm.stopPrank();
    }
}



================================================
FILE: test/bridge/PreAllocatedLeaves.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeAdminManager.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor() ERC20("Test Token", "TEST") {
        _mint(msg.sender, 1000000 ether);
    }
}

/**
 * @title PreAllocatedLeavesTest
 * @notice Test the pre-allocated leaves system
 */
contract PreAllocatedLeavesTest is Test {
    BridgeCore public bridge;
    BridgeAdminManager public adminManager;
    TestToken public testToken;

    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");

    function setUp() public {
        vm.startPrank(owner);

        testToken = new TestToken();

        // Deploy core contract with proxy
        BridgeCore implementation = new BridgeCore();
        bytes memory bridgeInitData =
            abi.encodeCall(BridgeCore.initialize, (address(0), address(0), address(0), address(0), owner));
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(implementation), bridgeInitData);
        bridge = BridgeCore(address(bridgeProxy));

        // Deploy admin manager
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();
        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        // Update bridge with manager addresses
        bridge.updateManagerAddresses(address(0), address(0), address(0), address(adminManager));

        vm.stopPrank();
    }

    function testSetupTonTransferPreAllocatedLeaf() public {
        vm.startPrank(owner);

        // First allow the target contract
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);

        // Setup TON transfer pre-allocated leaf
        adminManager.setupTonTransferPreAllocatedLeaf(address(testToken));

        // Verify the pre-allocated leaf was set correctly
        (uint256 value, bool exists) = adminManager.getPreAllocatedLeaf(address(testToken), bytes32(uint256(0x07)));
        assertTrue(exists, "Pre-allocated leaf should exist");
        assertEq(value, 18, "Pre-allocated leaf value should be 18 (decimals)");

        // Get all pre-allocated keys
        bytes32[] memory keys = bridge.getPreAllocatedKeys(address(testToken));
        assertEq(keys.length, 1, "Should have 1 pre-allocated key");
        assertEq(keys[0], bytes32(uint256(0x07)), "First key should be 0x07");

        vm.stopPrank();
    }

    function testCustomPreAllocatedLeaf() public {
        vm.startPrank(owner);

        // First allow the target contract
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);

        // Set a custom pre-allocated leaf
        bytes32 customKey = bytes32(uint256(0x42));
        uint256 customValue = 1337;
        adminManager.setPreAllocatedLeaf(address(testToken), customKey, customValue);

        // Verify the custom pre-allocated leaf
        (uint256 value, bool exists) = adminManager.getPreAllocatedLeaf(address(testToken), customKey);
        assertTrue(exists, "Custom pre-allocated leaf should exist");
        assertEq(value, customValue, "Custom pre-allocated leaf value should match");

        vm.stopPrank();
    }

    function testMultiplePreAllocatedLeaves() public {
        vm.startPrank(owner);

        // First allow the target contract
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);

        // Set multiple pre-allocated leaves
        adminManager.setPreAllocatedLeaf(address(testToken), bytes32(uint256(0x01)), 100);
        adminManager.setPreAllocatedLeaf(address(testToken), bytes32(uint256(0x02)), 200);
        adminManager.setPreAllocatedLeaf(address(testToken), bytes32(uint256(0x03)), 300);

        // Get all pre-allocated keys
        bytes32[] memory keys = bridge.getPreAllocatedKeys(address(testToken));
        assertEq(keys.length, 3, "Should have 3 pre-allocated keys");

        vm.stopPrank();
    }

    function testRemovePreAllocatedLeaf() public {
        vm.startPrank(owner);

        // First allow the target contract
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);

        // Set a pre-allocated leaf
        bytes32 testKey = bytes32(uint256(0x42));
        adminManager.setPreAllocatedLeaf(address(testToken), testKey, 1337);

        // Verify it exists
        (uint256 value, bool exists) = adminManager.getPreAllocatedLeaf(address(testToken), testKey);
        assertTrue(exists, "Pre-allocated leaf should exist");

        // Remove it
        adminManager.removePreAllocatedLeaf(address(testToken), testKey);

        // Verify it no longer exists
        (value, exists) = adminManager.getPreAllocatedLeaf(address(testToken), testKey);
        assertFalse(exists, "Pre-allocated leaf should not exist after removal");

        vm.stopPrank();
    }

    function testChannelOpeningWithPreAllocatedLeaves() public {
        vm.startPrank(owner);

        // First allow the target contract
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);

        // Setup TON transfer pre-allocated leaf (1 leaf)
        adminManager.setupTonTransferPreAllocatedLeaf(address(testToken));

        vm.stopPrank();

        // Create participants
        // With 1 balance slot: numberOfUserStorageSlot = 1
        // With 1 pre-allocated leaf: preAllocatedCount = 1
        // maxAllowedParticipants = ((128 - 1) / 1) - 1 = 127 - 1 = 126
        address[] memory participants = new address[](126);
        for (uint256 i = 0; i < 126; i++) {
            participants[i] = address(uint160(i + 1));
        }

        vm.startPrank(user1);

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "preAllocTest1"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(testToken),
            whitelisted: participants,
            enableFrostSignature: true
        });

        // This should succeed with 126 participants (plus leader = 127 total)
        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);

        // Verify the channel has the correct pre-allocated leaves count
        uint256 preAllocatedCount = bridge.getChannelPreAllocatedLeavesCount(returnedChannelId);
        assertEq(preAllocatedCount, 1, "Channel should have 1 pre-allocated leaf");

        vm.stopPrank();
    }

    function testChannelOpeningFailsWithTooManyParticipants() public {
        vm.startPrank(owner);

        // First allow the target contract
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(testToken), emptySlots, balanceSlot, true);

        // Setup TON transfer pre-allocated leaf (1 leaf)
        adminManager.setupTonTransferPreAllocatedLeaf(address(testToken));

        vm.stopPrank();

        // Try to create with 127 participants (max is 126, should fail)
        // maxAllowedParticipants = ((128 - 1) / 1) - 1 = 127 - 1 = 126
        address[] memory participants = new address[](127);
        for (uint256 i = 0; i < 127; i++) {
            participants[i] = address(uint160(i + 1));
        }

        vm.startPrank(user1);

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "preAllocTest2"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(testToken),
            whitelisted: participants,
            enableFrostSignature: true
        });

        // This should fail
        vm.expectRevert("Invalid whitelisted count considering pre-allocated leaves");
        bridge.openChannel(params);

        vm.stopPrank();
    }
}



================================================
FILE: test/bridge/ProofSubmission.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/BridgeDepositManager.sol";
import "../../src/BridgeWithdrawManager.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/ITokamakVerifier.sol";
import "../../src/interface/IZecFrost.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import {ZecFrost} from "../../src/library/ZecFrost.sol";
import {TokamakVerifier} from "../../src/verifier/TokamakVerifier.sol";
import {Groth16Verifier16Leaves} from "../../src/verifier/Groth16Verifier16Leaves.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

// Mock Contracts
contract MockTokamakVerifier is ITokamakVerifier {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verify(
        uint128[] calldata,
        uint256[] calldata,
        uint128[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        uint256
    ) external view override returns (bool) {
        return shouldVerify;
    }
}

contract MockZecFrost is IZecFrost {
    address public mockSigner;

    constructor() {
        mockSigner = address(this);
    }

    function verify(bytes32, uint256, uint256, uint256, uint256, uint256) external view override returns (address) {
        return mockSigner;
    }

    function setMockSigner(address _signer) external {
        mockSigner = _signer;
    }
}

contract MockGroth16Verifier is IGroth16Verifier16Leaves {
    bool public shouldVerify = true;

    function setShouldVerify(bool _should) external {
        shouldVerify = _should;
    }

    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[33] calldata)
        external
        view
        returns (bool)
    {
        return shouldVerify;
    }
}

contract TestERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 _decimals) ERC20(name, symbol) {
        _setupDecimals(_decimals);
    }

    function _setupDecimals(uint8 _decimals) internal {
        // Note: This is a simplified mock. In production, you'd use OpenZeppelin's approach
        // For testing purposes, we'll just mint tokens to test addresses
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return super.decimals();
    }
}

contract ProofSubmissionTest is Test {
    BridgeCore public bridge;
    BridgeDepositManager public depositManager;
    BridgeProofManager public proofManager;
    BridgeWithdrawManager public withdrawManager;
    BridgeAdminManager public adminManager;

    MockTokamakVerifier public mockVerifier;
    MockZecFrost public mockZecFrost;
    MockGroth16Verifier public mockGroth16Verifier;

    TestERC20 public token;

    address public leader = address(0x1);
    address public user1 = address(0x2);
    address public user2 = address(0x3);
    address public owner = address(0x4);

    uint128[] public proofPart1;
    uint256[] public proofPart2;
    uint256[] public publicInputs;

    function setUp() public {
        vm.startPrank(owner);

        // Deploy mock contracts
        mockVerifier = new MockTokamakVerifier();
        mockZecFrost = new MockZecFrost();
        mockGroth16Verifier = new MockGroth16Verifier();

        // Deploy test token
        token = new TestERC20("TestToken", "TT", 18);

        // Deploy implementation contracts
        BridgeCore bridgeImpl = new BridgeCore();
        BridgeDepositManager depositManagerImpl = new BridgeDepositManager();
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();
        BridgeProofManager proofManagerImpl = new BridgeProofManager();
        BridgeWithdrawManager withdrawManagerImpl = new BridgeWithdrawManager();

        address[4] memory groth16Verifiers = [
            address(mockGroth16Verifier),
            address(mockGroth16Verifier),
            address(mockGroth16Verifier),
            address(mockGroth16Verifier)
        ];

        // Deploy bridge with proxy pattern first
        bytes memory bridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(0), address(0), address(0), address(0), owner) // Temporary addresses
        );
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(bridgeImpl), bridgeInitData);
        bridge = BridgeCore(payable(address(bridgeProxy)));

        // Deploy manager contracts as proxies
        bytes memory depositInitData = abi.encodeCall(BridgeDepositManager.initialize, (address(bridge), owner));
        ERC1967Proxy depositProxy = new ERC1967Proxy(address(depositManagerImpl), depositInitData);
        depositManager = BridgeDepositManager(address(depositProxy));

        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        bytes memory proofInitData = abi.encodeCall(
            BridgeProofManager.initialize,
            (address(bridge), address(mockVerifier), address(mockZecFrost), groth16Verifiers, owner)
        );
        ERC1967Proxy proofProxy = new ERC1967Proxy(address(proofManagerImpl), proofInitData);
        proofManager = BridgeProofManager(address(proofProxy));

        bytes memory withdrawInitData = abi.encodeCall(BridgeWithdrawManager.initialize, (address(bridge), owner));
        ERC1967Proxy withdrawProxy = new ERC1967Proxy(address(withdrawManagerImpl), withdrawInitData);
        withdrawManager = BridgeWithdrawManager(payable(address(withdrawProxy)));

        // Update bridge with manager addresses
        bridge.updateManagerAddresses(
            address(depositManager), address(proofManager), address(withdrawManager), address(adminManager)
        );

        // Register the test token and its transfer function
        uint128[] memory preprocessedPart1 = new uint128[](4);
        uint256[] memory preprocessedPart2 = new uint256[](4);
        bytes32 transferSig = bytes32(bytes4(keccak256("transfer(address,uint256)")));

        // Use the actual registered function instance hash from the deployed contract
        bytes32 functionInstanceHash = 0xd157cb883adb9cb0e27d9dc419e2a4be817d856281b994583b5bae64be94d35a;

        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(token), emptySlots, balanceSlot, true);
        adminManager.registerFunction(
            address(token), transferSig, preprocessedPart1, preprocessedPart2, functionInstanceHash
        );

        vm.stopPrank();
    }

    function setupChannelWithDeposits() public returns (bytes32 channelId) {
        vm.startPrank(leader);
        vm.deal(leader, 10 ether);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = leader;

        channelId = keccak256(abi.encode(address(this), block.timestamp, "proofSubmissionChannel"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: true
        });

        bytes32 returnedChannelId = bridge.openChannel(params);
        assertEq(returnedChannelId, channelId);
        bridge.setChannelPublicKey(
            channelId,
            0x51909117a840e98bbcf1aae0375c6e85920b641edee21518cb79a19ac347f638,
            0xf2cf51268a560b92b57994c09af3c129e7f5646a48e668564edde80fd5076c6e
        );
        vm.stopPrank();

        // Make deposits to become participants
        token.mint(user1, 1000e18);
        vm.startPrank(user1);
        token.approve(address(depositManager), 2e18);
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(uint256(10));
        depositManager.depositToken(channelId, 2e18, mptKeys1);
        vm.stopPrank();

        token.mint(user2, 1000e18);
        vm.startPrank(user2);
        token.approve(address(depositManager), 500e18);
        bytes32[] memory mptKeys2 = new bytes32[](1);
        mptKeys2[0] = bytes32(uint256(20));
        depositManager.depositToken(channelId, 500e18, mptKeys2);
        vm.stopPrank();

        token.mint(leader, 1000e18);
        vm.startPrank(leader);
        token.approve(address(depositManager), 1e18);
        bytes32[] memory mptKeys3 = new bytes32[](1);
        mptKeys3[0] = bytes32(uint256(30));
        depositManager.depositToken(channelId, 1e18, mptKeys3);
        vm.stopPrank();
    }

    function computeCorrectFunctionInstanceHash() public pure returns (bytes32) {
        uint256[] memory correctData = new uint256[](446);

        // Set specific known values that should hash to the correct instance hash
        correctData[0] = 0x01;
        correctData[1] = 0xffffffffffffffffffffffffffffffff;
        correctData[2] = 0xffffffff;

        return keccak256(abi.encodePacked(correctData));
    }

    function testcheckInstanceHash() public pure {
        bytes32 expectedHash = computeCorrectFunctionInstanceHash();
        console.logBytes32(expectedHash);
    }
}



================================================
FILE: test/bridge/TimeoutWithdrawal.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeDepositManager.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/BridgeWithdrawManager.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/ITokamakVerifier.sol";
import "../../src/interface/IZecFrost.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import "../../src/interface/IGroth16Verifier32Leaves.sol";
import "../../src/interface/IGroth16Verifier64Leaves.sol";
import "../../src/interface/IGroth16Verifier128Leaves.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";

// Mock Contracts
contract MockToken is ERC20 {
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals_) ERC20(name, symbol) {
        _decimals = decimals_;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockZecFrost is IZecFrost {
    function verify(bytes32 message, uint256 pkx, uint256 pky, uint256 rx, uint256 ry, uint256 z)
        external
        pure
        returns (address)
    {
        // Always return a fixed address for testing
        return address(0x1234567890123456789012345678901234567890);
    }
}

contract MockTokamakVerifier is ITokamakVerifier {
    function verify(
        uint128[] calldata proofPart1,
        uint256[] calldata proofPart2,
        uint128[] calldata preprocessedPart1,
        uint256[] calldata preprocessedPart2,
        uint256[] calldata publicInputs,
        uint256 smax
    ) external pure returns (bool) {
        return true;
    }
}

contract MockGroth16Verifier is IGroth16Verifier16Leaves, IGroth16Verifier32Leaves, IGroth16Verifier64Leaves, IGroth16Verifier128Leaves {
    function verifyProof(uint256[4] calldata pA, uint256[8] calldata pB, uint256[4] calldata pC, uint256[33] calldata publicSignals)
        external
        pure
        returns (bool)
    {
        return true;
    }

    function verifyProof(uint256[4] calldata pA, uint256[8] calldata pB, uint256[4] calldata pC, uint256[65] calldata publicSignals)
        external
        pure
        returns (bool)
    {
        return true;
    }

    function verifyProof(uint256[4] calldata pA, uint256[8] calldata pB, uint256[4] calldata pC, uint256[129] calldata publicSignals)
        external
        pure
        returns (bool)
    {
        return true;
    }

    function verifyProof(uint256[4] calldata pA, uint256[8] calldata pB, uint256[4] calldata pC, uint256[257] calldata publicSignals)
        external
        pure
        returns (bool)
    {
        return true;
    }
}

contract TimeoutWithdrawalTest is Test {
    BridgeCore public bridge;
    BridgeDepositManager public depositManager;
    BridgeProofManager public proofManager;
    BridgeWithdrawManager public withdrawManager;
    BridgeAdminManager public adminManager;
    MockToken public token;
    MockTokamakVerifier public zkVerifier;
    MockZecFrost public zecFrost;
    MockGroth16Verifier public groth16Verifier16;
    MockGroth16Verifier public groth16Verifier32;
    MockGroth16Verifier public groth16Verifier64;
    MockGroth16Verifier public groth16Verifier128;

    address public owner = address(this);
    address public leader = makeAddr("leader");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");

    bytes32 public channelId;
    uint256 public constant DEPOSIT_AMOUNT = 1 ether;

    event Withdrawn(bytes32 indexed channelId, address indexed user, address token, uint256 amount);

    function setUp() public {
        // Set proper block number to avoid underflow in blockhash calculations
        vm.roll(10);
        
        // Deploy mock contracts
        token = new MockToken("TestToken", "TT", 18);
        zkVerifier = new MockTokamakVerifier();
        zecFrost = new MockZecFrost();
        groth16Verifier16 = new MockGroth16Verifier();
        groth16Verifier32 = new MockGroth16Verifier();
        groth16Verifier64 = new MockGroth16Verifier();
        groth16Verifier128 = new MockGroth16Verifier();

        // Deploy manager implementations
        BridgeDepositManager depositManagerImpl = new BridgeDepositManager();
        BridgeWithdrawManager withdrawManagerImpl = new BridgeWithdrawManager();
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();
        BridgeProofManager proofManagerImpl = new BridgeProofManager();

        // Deploy core contract with proxy first
        BridgeCore implementation = new BridgeCore();
        bytes memory bridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(0), address(0), address(0), address(0), owner) // Temporary addresses
        );
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(implementation), bridgeInitData);
        bridge = BridgeCore(address(bridgeProxy));

        // Deploy manager proxies with bridge address
        bytes memory depositInitData = abi.encodeCall(BridgeDepositManager.initialize, (address(bridge), owner));
        ERC1967Proxy depositProxy = new ERC1967Proxy(address(depositManagerImpl), depositInitData);
        depositManager = BridgeDepositManager(address(depositProxy));

        bytes memory withdrawInitData = abi.encodeCall(BridgeWithdrawManager.initialize, (address(bridge), owner));
        ERC1967Proxy withdrawProxy = new ERC1967Proxy(address(withdrawManagerImpl), withdrawInitData);
        withdrawManager = BridgeWithdrawManager(address(withdrawProxy));

        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        address[4] memory groth16Verifiers = [
            address(groth16Verifier16),
            address(groth16Verifier32),
            address(groth16Verifier64),
            address(groth16Verifier128)
        ];
        bytes memory proofInitData = abi.encodeCall(
            BridgeProofManager.initialize,
            (address(bridge), address(zkVerifier), address(zecFrost), groth16Verifiers, owner)
        );
        ERC1967Proxy proofProxy = new ERC1967Proxy(address(proofManagerImpl), proofInitData);
        proofManager = BridgeProofManager(address(proofProxy));

        // Update managers to point to the correct bridge and update bridge with manager addresses
        vm.startPrank(owner);
        
        // Create a new bridge with the correct manager addresses
        BridgeCore newImplementation = new BridgeCore();
        bytes memory correctBridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(depositManager), address(proofManager), address(withdrawManager), address(adminManager), owner)
        );
        ERC1967Proxy newBridgeProxy = new ERC1967Proxy(address(newImplementation), correctBridgeInitData);
        bridge = BridgeCore(address(newBridgeProxy));

        // Update all managers to point to the new bridge
        depositManager.updateBridge(address(bridge));
        withdrawManager.updateBridge(address(bridge));
        proofManager.updateBridge(address(bridge));
        adminManager.updateBridge(address(bridge));
        
        vm.stopPrank();

        // Set up allowed target contract with balance slot
        vm.startPrank(owner);
        IBridgeCore.PreAllocatedLeaf[] memory emptyLeaves = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(token), emptyLeaves, balanceSlot, true);
        vm.stopPrank();

        // Mint tokens to participants and leader
        token.mint(user1, 10 ether);
        token.mint(user2, 10 ether);
        token.mint(user3, 10 ether);
        token.mint(leader, 10 ether);

        // Setup channel
        _setupChannel();
    }

    function _setupChannel() internal {
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        channelId = keccak256(abi.encode(leader, block.timestamp, "timeout_test"));

        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(token),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bridge.openChannel(params);

        // Leader must deposit before initializing
        token.approve(address(depositManager), DEPOSIT_AMOUNT);
        bytes32[] memory mptKeysLeader = new bytes32[](1);
        mptKeysLeader[0] = bytes32(uint256(999));
        depositManager.depositToken(channelId, DEPOSIT_AMOUNT, mptKeysLeader);
        vm.stopPrank();

        // Make deposits
        _makeDeposits();
    }

    function _makeDeposits() internal {
        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        for (uint256 i = 0; i < participants.length; i++) {
            vm.startPrank(participants[i]);
            token.approve(address(depositManager), DEPOSIT_AMOUNT);
            bytes32[] memory mptKeys = new bytes32[](1);
            mptKeys[0] = bytes32(uint256(i + 1));
            depositManager.depositToken(channelId, DEPOSIT_AMOUNT, mptKeys);
            vm.stopPrank();
        }
    }

    function _initializeChannel() internal {
        vm.startPrank(leader);
        
        BridgeProofManager.ChannelInitializationProof memory mockProof = BridgeProofManager.ChannelInitializationProof({
            pA: [uint256(1), uint256(2), uint256(3), uint256(4)],
            pB: [uint256(5), uint256(6), uint256(7), uint256(8), uint256(9), uint256(10), uint256(11), uint256(12)],
            pC: [uint256(13), uint256(14), uint256(15), uint256(16)],
            merkleRoot: keccak256(abi.encodePacked("mockRoot"))
        });
        
        proofManager.initializeChannelState(channelId, mockProof);
        vm.stopPrank();
    }

    function testWithdrawOnTimeoutSuccess() public {
        _initializeChannel();

        // Fast forward past timeout
        vm.warp(block.timestamp + bridge.CHANNEL_TIMEOUT() + 1);

        uint256 initialTokenBalance = token.balanceOf(user1);

        vm.expectEmit(true, true, true, true);
        emit Withdrawn(channelId, user1, address(token), DEPOSIT_AMOUNT);

        vm.prank(user1);
        withdrawManager.withdraw(channelId, address(token));

        // Check user received their deposit back
        assertEq(token.balanceOf(user1), initialTokenBalance + DEPOSIT_AMOUNT);

        // Verify user's validatedUserStorage is cleared after withdrawal
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 0);
    }

    function testWithdrawOnTimeoutBeforeTimeout() public {
        _initializeChannel();

        vm.expectRevert("Channel must be deleted or timed out");
        vm.prank(user1);
        withdrawManager.withdraw(channelId, address(token));
    }

    function testWithdrawOnTimeoutAlreadyWithdrawn() public {
        _initializeChannel();

        // Fast forward past timeout
        vm.warp(block.timestamp + bridge.CHANNEL_TIMEOUT() + 1);

        // First withdrawal
        vm.prank(user1);
        withdrawManager.withdraw(channelId, address(token));

        // Try to withdraw again
        vm.expectRevert("No withdrawable amount");
        vm.prank(user1);
        withdrawManager.withdraw(channelId, address(token));
    }

    function testWithdrawOnTimeoutNotParticipant() public {
        _initializeChannel();

        // Fast forward past timeout
        vm.warp(block.timestamp + bridge.CHANNEL_TIMEOUT() + 1);

        address nonParticipant = makeAddr("nonParticipant");

        // Non-participants have no ValidatedUserStorage entry, so targetContract validation fails first
        vm.expectRevert("Target contract mismatch");
        vm.prank(nonParticipant);
        withdrawManager.withdraw(channelId, address(token));
    }



    function testMultipleUsersCanWithdrawOnTimeout() public {
        _initializeChannel();

        // Fast forward past timeout
        vm.warp(block.timestamp + bridge.CHANNEL_TIMEOUT() + 1);

        uint256 user1InitialBalance = token.balanceOf(user1);
        uint256 user2InitialBalance = token.balanceOf(user2);

        // User1 withdraws
        vm.prank(user1);
        withdrawManager.withdraw(channelId, address(token));

        // User2 withdraws
        vm.prank(user2);
        withdrawManager.withdraw(channelId, address(token));

        // Both should have received their deposits back
        assertEq(token.balanceOf(user1), user1InitialBalance + DEPOSIT_AMOUNT);
        assertEq(token.balanceOf(user2), user2InitialBalance + DEPOSIT_AMOUNT);

        // Verify both users' validatedUserStorage is cleared after withdrawal
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 0);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user2, 0), 0);
    }

    function _submitMockProof() internal {
        BridgeProofManager.ProofData[] memory proofs = new BridgeProofManager.ProofData[](1);
        uint256[] memory publicInputs = new uint256[](64);
        
        // Get the initial state root from the channel
        bytes32 initialStateRoot = bridge.getChannelInitialStateRoot(channelId);
        bytes32 finalStateRoot = keccak256(abi.encodePacked("finalRoot"));
        
        // Set required public inputs for state root validation
        publicInputs[0] = uint256(finalStateRoot) >> 128; // final state root part 1
        publicInputs[1] = uint256(finalStateRoot) & ((1 << 128) - 1); // final state root part 2
        publicInputs[8] = uint256(initialStateRoot) >> 128; // initial state root part 1
        publicInputs[9] = uint256(initialStateRoot) & ((1 << 128) - 1); // initial state root part 2
        
        // Set block info data to match the stored blockInfosHash
        bytes32 storedBlockInfoHash = bridge.getChannelBlockInfosHash(channelId);
        // For mock purposes, we'll just set some basic block info that should work
        for (uint256 i = 40; i < 64; i += 2) {
            publicInputs[i] = 0; // mock block info data - simplified for testing
            publicInputs[i + 1] = 0;
        }
        
        proofs[0] = BridgeProofManager.ProofData({
            proofPart1: new uint128[](8),
            proofPart2: new uint256[](8), 
            publicInputs: publicInputs,
            smax: 1000
        });

        BridgeProofManager.Signature memory signature = BridgeProofManager.Signature({
            message: bytes32(0),
            rx: 0,
            ry: 0,
            z: 0
        });

        proofManager.submitProofAndSignature(channelId, proofs, signature);
    }
}


================================================
FILE: test/bridge/UserStorageSlots.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/BridgeDepositManager.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/ITokamakVerifier.sol";
import "../../src/interface/IZecFrost.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import "../../src/library/ZecFrost.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

// Mock USDT-like token with blacklist functionality
contract MockUSDT is ERC20 {
    mapping(address => bool) private _isBlackListed;

    constructor() ERC20("Mock USDT", "USDT") {
        _mint(msg.sender, 1000000 ether);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function addBlackList(address _evilUser) external {
        _isBlackListed[_evilUser] = true;
    }

    function removeBlackList(address _clearedUser) external {
        _isBlackListed[_clearedUser] = false;
    }

    function isBlackListed(address _maker) external view returns (bool) {
        return _isBlackListed[_maker];
    }

    // Override transfer to check blacklist
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(!_isBlackListed[msg.sender], "Sender is blacklisted");
        require(!_isBlackListed[to], "Recipient is blacklisted");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        require(!_isBlackListed[from], "Sender is blacklisted");
        require(!_isBlackListed[to], "Recipient is blacklisted");
        return super.transferFrom(from, to, amount);
    }
}

contract MockTokamakVerifier is ITokamakVerifier {
    function verify(
        uint128[] calldata,
        uint256[] calldata,
        uint128[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        uint256
    ) external pure returns (bool) {
        return true;
    }
}

contract MockGroth16Verifier is IGroth16Verifier16Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[33] calldata)
        external
        pure
        returns (bool)
    {
        return true;
    }
}

/**
 * @title UserStorageSlotsTest
 * @notice Test initializeChannelState with additional user storage slots (like USDT's isBlackListed)
 */
contract UserStorageSlotsTest is Test {
    BridgeCore public bridge;
    BridgeProofManager public proofManager;
    BridgeDepositManager public depositManager;
    BridgeAdminManager public adminManager;

    MockTokamakVerifier public tokamakVerifier;
    MockGroth16Verifier public groth16Verifier;
    ZecFrost public zecFrost;
    MockUSDT public usdt;

    address public owner = makeAddr("owner");
    address public leader = makeAddr("leader");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");

    function setUp() public {
        // Set block number to avoid underflow in blockhash calculations
        vm.roll(100);

        vm.startPrank(owner);

        // Deploy mock contracts
        tokamakVerifier = new MockTokamakVerifier();
        groth16Verifier = new MockGroth16Verifier();
        zecFrost = new ZecFrost();
        usdt = new MockUSDT();

        // Deploy manager implementations
        BridgeDepositManager depositManagerImpl = new BridgeDepositManager();
        BridgeProofManager proofManagerImpl = new BridgeProofManager();
        BridgeAdminManager adminManagerImpl = new BridgeAdminManager();

        // Deploy core contract with proxy
        BridgeCore implementation = new BridgeCore();
        bytes memory bridgeInitData = abi.encodeCall(
            BridgeCore.initialize,
            (address(0), address(0), address(0), address(0), owner)
        );
        ERC1967Proxy bridgeProxy = new ERC1967Proxy(address(implementation), bridgeInitData);
        bridge = BridgeCore(address(bridgeProxy));

        // Deploy manager proxies
        bytes memory depositInitData = abi.encodeCall(BridgeDepositManager.initialize, (address(bridge), owner));
        ERC1967Proxy depositProxy = new ERC1967Proxy(address(depositManagerImpl), depositInitData);
        depositManager = BridgeDepositManager(address(depositProxy));

        address[4] memory groth16Verifiers =
            [address(groth16Verifier), address(groth16Verifier), address(groth16Verifier), address(groth16Verifier)];
        bytes memory proofInitData = abi.encodeCall(
            BridgeProofManager.initialize,
            (address(bridge), address(tokamakVerifier), address(zecFrost), groth16Verifiers, owner)
        );
        ERC1967Proxy proofProxy = new ERC1967Proxy(address(proofManagerImpl), proofInitData);
        proofManager = BridgeProofManager(address(proofProxy));

        bytes memory adminInitData = abi.encodeCall(BridgeAdminManager.initialize, (address(bridge), owner));
        ERC1967Proxy adminProxy = new ERC1967Proxy(address(adminManagerImpl), adminInitData);
        adminManager = BridgeAdminManager(address(adminProxy));

        // Update manager addresses
        bridge.updateManagerAddresses(
            address(depositManager), address(proofManager), address(0), address(adminManager)
        );
        depositManager.updateBridge(address(bridge));
        proofManager.updateBridge(address(bridge));
        adminManager.updateBridge(address(bridge));

        // Set up USDT as allowed target contract with balance + isBlackListed slots
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory userStorageSlots = new IBridgeCore.UserStorageSlot[](2);

        // Slot 0: balance (not loaded from chain, comes from deposits)
        userStorageSlots[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 2, // USDT balance slot offset
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });

        // Slot 1: isBlackListed (loaded from chain via staticcall)
        userStorageSlots[1] = IBridgeCore.UserStorageSlot({
            slotOffset: 6, // USDT isBlackListed slot offset
            getterFunctionSignature: bytes32(bytes4(keccak256("isBlackListed(address)"))),
            isLoadedOnChain: true
        });

        adminManager.setAllowedTargetContract(address(usdt), emptySlots, userStorageSlots, true);

        // Mint tokens to participants
        usdt.mint(leader, 100 ether);
        usdt.mint(user1, 100 ether);
        usdt.mint(user2, 100 ether);
        usdt.mint(user3, 100 ether);

        vm.stopPrank();
    }

    function testInitializeChannelStateWithBlacklistSlot() public {
        // Create channel
        vm.startPrank(leader);

        address[] memory participants = new address[](3);
        participants[0] = user1;
        participants[1] = user2;
        participants[2] = user3;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "testBlacklist"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(usdt),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bridge.openChannel(params);
        vm.stopPrank();

        // Deposit tokens (2 mptKeys each: balance + isBlackListed)
        vm.startPrank(user1);
        usdt.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](2);
        mptKeys1[0] = bytes32(uint256(1)); // balance slot
        mptKeys1[1] = bytes32(uint256(101)); // isBlackListed slot
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        usdt.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](2);
        mptKeys2[0] = bytes32(uint256(2));
        mptKeys2[1] = bytes32(uint256(102));
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        vm.startPrank(user3);
        usdt.approve(address(depositManager), 15 ether);
        bytes32[] memory mptKeys3 = new bytes32[](2);
        mptKeys3[0] = bytes32(uint256(3));
        mptKeys3[1] = bytes32(uint256(103));
        depositManager.depositToken(channelId, 15 ether, mptKeys3);
        vm.stopPrank();

        // Leader deposits to participate
        vm.startPrank(leader);
        usdt.approve(address(depositManager), 5 ether);
        bytes32[] memory mptKeys4 = new bytes32[](2);
        mptKeys4[0] = bytes32(uint256(4));
        mptKeys4[1] = bytes32(uint256(104));
        depositManager.depositToken(channelId, 5 ether, mptKeys4);
        vm.stopPrank();

        // Blacklist user3 AFTER deposits (to test staticcall fetches blacklist status correctly)
        vm.prank(owner);
        usdt.addBlackList(user3);

        // Verify balances are tracked
        assertEq(bridge.getValidatedUserSlotValue(channelId, user1, 0), 10 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user2, 0), 20 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, user3, 0), 15 ether);
        assertEq(bridge.getValidatedUserSlotValue(channelId, leader, 0), 5 ether);

        // Verify blacklist status
        assertFalse(usdt.isBlackListed(user1));
        assertFalse(usdt.isBlackListed(user2));
        assertTrue(usdt.isBlackListed(user3)); // user3 is blacklisted
        assertFalse(usdt.isBlackListed(leader));

        // Initialize channel state with proof
        vm.startPrank(leader);

        uint256[4] memory pA;
        uint256[8] memory pB;
        uint256[4] memory pC;

        BridgeProofManager.ChannelInitializationProof memory proof = BridgeProofManager.ChannelInitializationProof({
            merkleRoot: bytes32(uint256(123456)),
            pA: pA,
            pB: pB,
            pC: pC
        });

        // This should work - the proof manager will fetch both balance and isBlackListed status
        // Tree structure will be:
        // - 4 participants
        // - Each has 2 leaves: balance + isBlackListed
        // - Total: 8 user leaves (4 participants * 2 slots each)
        // - Tree size should be 16 (minimum that fits 8 leaves)
        proofManager.initializeChannelState(channelId, proof);

        vm.stopPrank();

        // Verify channel state changed to Open
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Open));

        // Verify tree size is correct (should be 16 to accommodate 4 participants * 2 storage slots each)
        assertEq(bridge.getChannelTreeSize(channelId), 16);
    }

    function testInitializeChannelStateWithoutBlacklist() public {
        // Create channel with simple ERC20 (no additional storage slots)
        MockUSDT simpleToken = new MockUSDT();

        vm.startPrank(owner);
        simpleToken.mint(leader, 100 ether);
        simpleToken.mint(user1, 100 ether);
        simpleToken.mint(user2, 100 ether);

        // Set up simple token with balance slot only
        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(address(simpleToken), emptySlots, balanceSlot, true);
        vm.stopPrank();

        // Create channel
        vm.startPrank(leader);

        address[] memory participants = new address[](2);
        participants[0] = user1;
        participants[1] = user2;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "testSimple"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(simpleToken),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bridge.openChannel(params);
        vm.stopPrank();

        // Deposit tokens (1 mptKey each: balance only for simple token)
        vm.startPrank(user1);
        simpleToken.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](1);
        mptKeys1[0] = bytes32(uint256(1));
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        simpleToken.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](1);
        mptKeys2[0] = bytes32(uint256(2));
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        vm.startPrank(leader);
        simpleToken.approve(address(depositManager), 5 ether);
        bytes32[] memory mptKeys3 = new bytes32[](1);
        mptKeys3[0] = bytes32(uint256(3));
        depositManager.depositToken(channelId, 5 ether, mptKeys3);
        vm.stopPrank();

        // Initialize channel state with proof
        vm.startPrank(leader);

        uint256[4] memory pA;
        uint256[8] memory pB;
        uint256[4] memory pC;

        BridgeProofManager.ChannelInitializationProof memory proof = BridgeProofManager.ChannelInitializationProof({
            merkleRoot: bytes32(uint256(123456)),
            pA: pA,
            pB: pB,
            pC: pC
        });

        // This should work - only balance leaves (no additional storage slots)
        // Tree structure will be:
        // - 3 participants
        // - Each has 1 leaf: balance only
        // - Total: 3 user leaves
        // - Tree size should be 16 (minimum)
        proofManager.initializeChannelState(channelId, proof);

        vm.stopPrank();

        // Verify channel state changed to Open
        assertEq(uint8(bridge.getChannelState(channelId)), uint8(IBridgeCore.ChannelState.Open));

        // Verify tree size (should be 16 for 3 participants with 1 slot each)
        assertEq(bridge.getChannelTreeSize(channelId), 16);
    }

    function testVerifyFinalBalancesWithUserStorageSlots() public {
        // Create channel with USDT (has isBlackListed slot)
        vm.startPrank(leader);

        address[] memory participants = new address[](2);
        participants[0] = user1;
        participants[1] = user2;

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, "testFinalBalances"));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: address(usdt),
            whitelisted: participants,
            enableFrostSignature: false
        });

        bridge.openChannel(params);
        vm.stopPrank();

        // Deposit tokens (2 mptKeys each: balance + isBlackListed)
        vm.startPrank(user1);
        usdt.approve(address(depositManager), 10 ether);
        bytes32[] memory mptKeys1 = new bytes32[](2);
        mptKeys1[0] = bytes32(uint256(1));
        mptKeys1[1] = bytes32(uint256(101));
        depositManager.depositToken(channelId, 10 ether, mptKeys1);
        vm.stopPrank();

        vm.startPrank(user2);
        usdt.approve(address(depositManager), 20 ether);
        bytes32[] memory mptKeys2 = new bytes32[](2);
        mptKeys2[0] = bytes32(uint256(2));
        mptKeys2[1] = bytes32(uint256(102));
        depositManager.depositToken(channelId, 20 ether, mptKeys2);
        vm.stopPrank();

        // Leader deposits to participate
        vm.startPrank(leader);
        usdt.approve(address(depositManager), 5 ether);
        bytes32[] memory mptKeys3 = new bytes32[](2);
        mptKeys3[0] = bytes32(uint256(3));
        mptKeys3[1] = bytes32(uint256(103));
        depositManager.depositToken(channelId, 5 ether, mptKeys3);
        vm.stopPrank();

        // Initialize channel state
        vm.startPrank(leader);

        uint256[4] memory pA;
        uint256[8] memory pB;
        uint256[4] memory pC;

        BridgeProofManager.ChannelInitializationProof memory initProof = BridgeProofManager.ChannelInitializationProof({
            merkleRoot: bytes32(uint256(123456)),
            pA: pA,
            pB: pB,
            pC: pC
        });

        proofManager.initializeChannelState(channelId, initProof);
        vm.stopPrank();

        // Set channel to Closing state manually for testing
        vm.prank(address(proofManager));
        bridge.setChannelState(channelId, BridgeCore.ChannelState.Closing);

        // Set final state root
        vm.prank(address(proofManager));
        bridge.setChannelFinalStateRoot(channelId, bytes32(uint256(789012)));

        // Verify final balances with user storage slots
        vm.startPrank(leader);

        // Final slot values: [balance, isBlackListed] for each participant
        uint256[][] memory finalSlotValues = new uint256[][](3);
        finalSlotValues[0] = new uint256[](2); // user1: balance + not blacklisted
        finalSlotValues[0][0] = 8 ether;       // balance
        finalSlotValues[0][1] = 0;             // not blacklisted
        finalSlotValues[1] = new uint256[](2); // user2: balance + not blacklisted
        finalSlotValues[1][0] = 22 ether;      // balance
        finalSlotValues[1][1] = 0;             // not blacklisted
        finalSlotValues[2] = new uint256[](2); // leader: balance + not blacklisted
        finalSlotValues[2][0] = 5 ether;       // balance
        finalSlotValues[2][1] = 0;             // not blacklisted

        // Permutation array: First all balances (3), then all isBlackListed (3) = 6 entries total
        uint256[] memory permutation = new uint256[](6);
        permutation[0] = 0; // user1 balance
        permutation[1] = 1; // user2 balance
        permutation[2] = 2; // leader balance
        permutation[3] = 3; // user1 isBlackListed
        permutation[4] = 4; // user2 isBlackListed
        permutation[5] = 5; // leader isBlackListed

        BridgeProofManager.ChannelFinalizationProof memory finalProof = BridgeProofManager.ChannelFinalizationProof({
            pA: pA,
            pB: pB,
            pC: pC
        });

        proofManager.updateValidatedUserStorage(channelId, finalSlotValues, permutation, finalProof);

        vm.stopPrank();

        // Verify channel was cleaned up (leader should be zero address)
        assertEq(bridge.getChannelLeader(channelId), address(0));
    }
}



================================================
FILE: test/bridge/VerifyFinalBalancesInput.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "../../src/BridgeProofManager.sol";
import "../../src/interface/IBridgeCore.sol";
import "../../src/interface/IGroth16Verifier16Leaves.sol";
import "../../src/interface/IGroth16Verifier32Leaves.sol";
import "../../src/interface/IGroth16Verifier64Leaves.sol";
import "../../src/interface/IGroth16Verifier128Leaves.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";

contract MockGroth16Verifier16 is IGroth16Verifier16Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[33] calldata)
        external
        pure
        override
        returns (bool)
    {
        return true;
    }
}

contract MockGroth16Verifier32 is IGroth16Verifier32Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[65] calldata)
        external
        pure
        override
        returns (bool)
    {
        return true;
    }
}

contract MockGroth16Verifier64 is IGroth16Verifier64Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[129] calldata)
        external
        pure
        override
        returns (bool)
    {
        return true;
    }
}

contract MockGroth16Verifier128 is IGroth16Verifier128Leaves {
    function verifyProof(uint256[4] calldata, uint256[8] calldata, uint256[4] calldata, uint256[257] calldata)
        external
        pure
        override
        returns (bool)
    {
        return true;
    }
}

contract MockBridgeCore {
    IBridgeCore.ChannelState public state;
    bool public frostEnabled;
    bool public signatureVerified;
    address[] public participants;
    bytes32 public finalStateRoot;
    uint256 public treeSize;
    address public targetContract;
    address public channelLeader;
    bool public isCleanedUp;
    mapping(address => mapping(uint8 => uint256)) public l2MptKeys;

    function setConfig(
        IBridgeCore.ChannelState _state,
        bool _frostEnabled,
        bool _signatureVerified,
        address[] calldata _participants,
        bytes32 _finalStateRoot,
        uint256 _treeSize,
        address _targetContract
    ) external {
        state = _state;
        frostEnabled = _frostEnabled;
        signatureVerified = _signatureVerified;
        finalStateRoot = _finalStateRoot;
        treeSize = _treeSize;
        targetContract = _targetContract;

        delete participants;
        for (uint256 i = 0; i < _participants.length; i++) {
            participants.push(_participants[i]);
        }
    }

    function setL2MptKey(address participant, uint8 slotIndex, uint256 key) external {
        l2MptKeys[participant][slotIndex] = key;
    }

    function getChannelState(bytes32) external view returns (IBridgeCore.ChannelState) {
        return state;
    }

    function isFrostSignatureEnabled(bytes32) external view returns (bool) {
        return frostEnabled;
    }

    function isSignatureVerified(bytes32) external view returns (bool) {
        return signatureVerified;
    }

    function getChannelParticipants(bytes32) external view returns (address[] memory) {
        return participants;
    }

    function getChannelFinalStateRoot(bytes32) external view returns (bytes32) {
        return finalStateRoot;
    }

    function getChannelTreeSize(bytes32) external view returns (uint256) {
        return treeSize;
    }

    function getChannelTargetContract(bytes32) external view returns (address) {
        return targetContract;
    }

    function getPreAllocatedLeavesCount(address) external pure returns (uint256) {
        return 0;
    }

    function getPreAllocatedKeys(address) external pure returns (bytes32[] memory keys) {
        return new bytes32[](0);
    }

    function getPreAllocatedLeaf(address, bytes32) external pure returns (uint256 value, bool exists) {
        return (0, false);
    }

    function getL2MptKey(bytes32, address participant, uint8 slotIndex) external view returns (uint256) {
        return l2MptKeys[participant][slotIndex];
    }

    function getTargetContractData(address) external pure returns (IBridgeCore.TargetContract memory) {
        // Return target contract data with balance slot only
        IBridgeCore.RegisteredFunction[] memory emptyFunctions = new IBridgeCore.RegisteredFunction[](0);
        IBridgeCore.PreAllocatedLeaf[] memory emptyLeaves = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false // balance comes from deposits
        });

        return IBridgeCore.TargetContract({
            preAllocatedLeaves: emptyLeaves,
            registeredFunctions: emptyFunctions,
            userStorageSlots: balanceSlot
        });
    }

    function setChannelValidatedUserStorage(bytes32, address[] memory, uint256[][] memory) external {}

    function getBalanceSlotIndex(address) external pure returns (uint8) {
        return 0; // Balance is always slot 0 in mock
    }

    function setChannelCloseTimestamp(bytes32, uint256) external {}

    function setChannelState(bytes32, IBridgeCore.ChannelState newState) external {
        state = newState;
    }

    function getChannelLeader(bytes32) external view returns (address) {
        return isCleanedUp ? address(0) : channelLeader;
    }

    function cleanupChannel(bytes32) external {
        isCleanedUp = true;
    }

    function setChannelLeader(address _leader) external {
        channelLeader = _leader;
        isCleanedUp = false;
    }
}

contract VerifyFinalBalancesInputTest is Test {
    BridgeProofManager private proofManager;
    MockBridgeCore private bridge;

    function setUp() public {
        bridge = new MockBridgeCore();
        MockGroth16Verifier16 verifier16 = new MockGroth16Verifier16();
        MockGroth16Verifier32 verifier32 = new MockGroth16Verifier32();
        MockGroth16Verifier64 verifier64 = new MockGroth16Verifier64();
        MockGroth16Verifier128 verifier128 = new MockGroth16Verifier128();

        BridgeProofManager implementation = new BridgeProofManager();
        address[4] memory groth16Verifiers =
            [address(verifier16), address(verifier32), address(verifier64), address(verifier128)];
        bytes memory initData = abi.encodeCall(
            BridgeProofManager.initialize, (address(bridge), address(0), address(0), groth16Verifiers, address(this))
        );
        ERC1967Proxy proxy = new ERC1967Proxy(address(implementation), initData);
        proofManager = BridgeProofManager(address(proxy));

        address[] memory participants = new address[](6);
        participants[0] = address(0x1);
        participants[1] = address(0x2);
        participants[2] = address(0x3);
        participants[3] = address(0x4);
        participants[4] = address(0x5);
        participants[5] = address(0x6);

        bridge.setConfig(
            IBridgeCore.ChannelState.Closing,
            false,
            false,
            participants,
            bytes32(uint256(0x1234)),
            16,
            address(0xBEEF)
        );

        // Set a channel leader for testing cleanup
        bridge.setChannelLeader(address(0x123));
    }

    function testVerifyFinalBalancesGroth16WithProvidedInputs() public {
        bytes32 channelId = bytes32(uint256(42));

        // Final slot values: balance only for each participant (slot 0)
        uint256[][] memory finalSlotValues = new uint256[][](6);
        finalSlotValues[0] = new uint256[](1);
        finalSlotValues[0][0] = 8_000000000000000000;
        finalSlotValues[1] = new uint256[](1);
        finalSlotValues[1][0] = 21_000000000000000000;
        finalSlotValues[2] = new uint256[](1);
        finalSlotValues[2][0] = 9_000000000000000000;
        finalSlotValues[3] = new uint256[](1);
        finalSlotValues[3][0] = 18_000000000000000000;
        finalSlotValues[4] = new uint256[](1);
        finalSlotValues[4][0] = 4_000000000000000000;
        finalSlotValues[5] = new uint256[](1);
        finalSlotValues[5][0] = 30_000000000000000000;

        uint256[] memory permutation = new uint256[](6);
        permutation[0] = 3;
        permutation[1] = 1;
        permutation[2] = 2;
        permutation[3] = 5;
        permutation[4] = 4;
        permutation[5] = 0;

        BridgeProofManager.ChannelFinalizationProof memory proof = BridgeProofManager.ChannelFinalizationProof({
            pA: [
                uint256(25546506726576549862703313676415253466),
                uint256(65946752761513164061266583987877524705193624113638805923614457567397607972749),
                uint256(24675421685932766870833412730604877816),
                uint256(58772741817313822323502079494608416713920431158614398725016740819096558635401)
            ],
            pB: [
                uint256(31347278282182569007908832442228656946),
                uint256(12665697616816053464553685608559496052136261122222142867729314109943591015754),
                uint256(6051998485137480424856207640890397089),
                uint256(87617300905886048105866437119239048073159957382564843056571516236237121608608),
                uint256(10634102124677411946799263515026313413),
                uint256(64040208428763102104370976949313845538807892975225355818699706868960574854068),
                uint256(9790437446372267409736494228062217688),
                uint256(84718647226524725255019004369863264203108205468972348680699883185005433632338)
            ],
            pC: [
                uint256(5813280287475954323271733704717975580),
                uint256(23763792764603797328692382840135723114106796924529151365650978050209750609770),
                uint256(3178742565597861311701415040477857415),
                uint256(44332132520306597723180470057924869519466279516040935671669539451214623582779)
            ]
        });

        (bool ok, bytes memory data) = address(proofManager).call(
            abi.encodeCall(
                BridgeProofManager.updateValidatedUserStorage, (channelId, finalSlotValues, permutation, proof)
            )
        );
        if (!ok) {
            revert(_decodeRevert(data));
        }
        // Channel should be cleaned up after verification, so leader should not exist
        assertEq(bridge.getChannelLeader(channelId), address(0));
    }

    function _decodeRevert(bytes memory data) private pure returns (string memory) {
        if (data.length < 68) {
            return "updateValidatedUserStorage reverted";
        }
        bytes4 selector;
        assembly {
            selector := mload(add(data, 0x20))
        }
        if (selector == 0x08c379a0) {
            assembly {
                data := add(data, 0x04)
            }
            return abi.decode(data, (string));
        }
        return "updateValidatedUserStorage reverted (non-string)";
    }
}



================================================
FILE: test/frost/ZecFrost.t.sol
================================================
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.29;

import {Test, console} from "forge-std/Test.sol";
import {ZecFrost} from "../../src/library/ZecFrost.sol";

contract ZecFrostTest is Test {
    ZecFrost zecFrost;

    function setUp() public {
        zecFrost = new ZecFrost();
    }

    function test_Verify01() public view {
        bytes32 message = 0x4141414141414141414141414141414141414141414141414141414141414141;

        uint256 px = 0x4F6340CFDD930A6F54E730188E3071D150877FA664945FB6F120C18B56CE1C09;
        uint256 py = 0x802A5E67C00A70D85B9A088EAC7CF5B9FB46AC5C0B2BD7D1E189FAC210F6B7EF;

        uint256 rx = 0x501DCFE29D881AA855BF25979BD79F751AA9536AF7A389403CD345B02D1E6F25;
        uint256 ry = 0x839AD3B762F50FE560F4688A15A1CAED522919F33928567F95BC48CBD9B8C771;

        uint256 z = 0x4FDEA9858F3E6484F1F0D64E7C17879C25F68DA8BD0E82B063CF7410DDF5A886;

        address addr;
        assembly ("memory-safe") {
            mstore(0x00, px)
            mstore(0x20, py)
            addr := and(keccak256(0x00, 0x40), sub(shl(160, 1), 1))
        }

        uint256 gasStart = gasleft();
        address result = zecFrost.verify(message, px, py, rx, ry, z);
        uint256 gasUsed = gasStart - gasleft();

        console.log("Gas used by FROST.verify:", gasUsed);

        assertEq(result, addr);
    }

    function test_VerifyWithInvalidPublicKey() public view {
        // bug originally found here:
        // https://github.com/chronicleprotocol/scribe/issues/56
        // merkleplant raised this topic in X and on forum:
        // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/19

        bytes32 message = 0x4141414141414141414141414141414141414141414141414141414141414141;

        // this bug with ecrecover happens when public key X
        // in range `[0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)`
        // this can happen with `1 / 2^128` chance

        uint256 px = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141; // public key x >= Secp256k1.N
        uint256 py = 0x98F66641CB0AE1776B463EBDEE3D77FE2658F021DB48E2C8AC7AB4C92F83621E;

        uint256 rx = 0x0000000000000000000000000000000000000000000000000000000000000001;
        uint256 ry = 0x4218F20AE6C646B363DB68605822FB14264CA8D2587FDD6FBC750D587E76A7EE;

        uint256 z = 0x4242424242424242424242424242424242424242424242424242424242424242;

        assertEq(zecFrost.verify(message, px, py, rx, ry, z), address(0));
        assertFalse(zecFrost.isValidPublicKey(px, py));
    }

    function test_VerifyCustomParameters() public view {
        bytes32 message = 0x91be4311c2af6d02623ae6bc08eed804a9394c0ebe344a273cacc4fa06c6e80b;

        uint256 px = 0x65ceb565a2028bcc940074da00994958c1965a0f801fc1a06811a1195426db0b;
        uint256 py = 0x767293b33676de95ce3d0acf97e1bb0326fe7e2896d17c4df5d7055b4699445c;

        uint256 rx = 0x00d1c2066f3cfb50b1882a2f85655c64fa1518edb27585ac64c9c1f853383a04;
        uint256 ry = 0x475633b801338dcd6167a445926dc0e20f051266e9038be76b433c0004ff2f9c;

        uint256 z = 0x4ed729ad86526f2599577c051225e9c15c0cd85861872c153b338da05b0bb946;

        address expectedAddr;
        assembly ("memory-safe") {
            mstore(0x00, px)
            mstore(0x20, py)
            expectedAddr := and(keccak256(0x00, 0x40), sub(shl(160, 1), 1))
        }

        uint256 gasStart = gasleft();
        address result = zecFrost.verify(message, px, py, rx, ry, z);
        uint256 gasUsed = gasStart - gasleft();

        console.log("Gas used by FROST.verify (custom params):", gasUsed);
        console.log("Expected address:", expectedAddr);
        console.log("Verified address:", result);
        console.logBytes32(message);

        assertTrue(zecFrost.isValidPublicKey(px, py), "Public key should be valid");
        assertEq(result, expectedAddr, "FROST signature should verify to expected address");
    }

    function test_AddressComputationDiscrepancy() public pure {
        uint256 px = 0x65ceb565a2028bcc940074da00994958c1965a0f801fc1a06811a1195426db0b;
        uint256 py = 0x767293b33676de95ce3d0acf97e1bb0326fe7e2896d17c4df5d7055b4699445c;

        // FROST/ZecFrost way: keccak256(px || py) -> truncate to 160 bits
        address frostAddr;
        assembly ("memory-safe") {
            mstore(0x00, px)
            mstore(0x20, py)
            frostAddr := and(keccak256(0x00, 0x40), sub(shl(160, 1), 1))
        }

        // BridgeCore way: keccak256(abi.encodePacked(px, py)) -> truncate to 160 bits
        bytes32 h = keccak256(abi.encodePacked(px, py));
        address bridgeCoreAddr = address(uint160(uint256(h)));

        console.log("FROST computed address:", frostAddr);
        console.log("BridgeCore computed address:", bridgeCoreAddr);
        console.log("BridgeCore expected (from issue):", address(0x86278a8c51E0789a19F19D84ed17bCdcaB1aC9b4));

        // They should be the same since abi.encodePacked(px, py) == px || py for uint256s
        assertEq(frostAddr, bridgeCoreAddr, "Address computation should be identical");
    }
}



================================================
FILE: test/groth16/128_leaves/Groth16Verifier128LeavesTest.t.sol
================================================
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../src/verifier/Groth16Verifier128Leaves.sol";
import "../../../src/verifier/Groth16Verifier128LeavesIC1.sol";
import "../../../src/verifier/Groth16Verifier128LeavesIC2.sol";

contract Groth16Verifier128LeavesTest is Test {
    Groth16Verifier128Leaves verifier;
    Groth16Verifier128LeavesIC1 icContract1;
    Groth16Verifier128LeavesIC2 icContract2;

    // BLS12-381 proof constants for 128 leaves
    uint256 constant pA_x_PART1 = 0x00000000000000000000000000000000076aed58b3189ab0a86591abf032f406;
    uint256 constant pA_x_PART2 = 0x3d85023cd1e1241c8c351225f94b4ab1b4a87abdd05af4d303cdff8103562d5c;
    uint256 constant pA_y_PART1 = 0x000000000000000000000000000000000cafae81f350610933c88c3ac2dfe6d9;
    uint256 constant pA_y_PART2 = 0x24ea6589895595bae03a864ac1c4a2e6d62f3f8a08d33fd19f4c8699bcf31655;

    uint256 constant pB_x0_PART1 = 0x000000000000000000000000000000000e5e674854319a6a8e4ab14c660881e1;
    uint256 constant pB_x0_PART2 = 0xc9762263b12f8661f50feb00e41de3a16708b7e37b64e2fc033cee3febcc6eb2;
    uint256 constant pB_x1_PART1 = 0x00000000000000000000000000000000085656305f6a8e4cfbb0599f71d2a269;
    uint256 constant pB_x1_PART2 = 0xb405d46a6299bf657abfb0f9b30d557b9e3df0d1f20f3c9b4f4681db41dd92a5;
    uint256 constant pB_y0_PART1 = 0x000000000000000000000000000000000ff9f7876abae6c6a37e0b2c5fd284e7;
    uint256 constant pB_y0_PART2 = 0x2a955d1e00bed62c8ed430a5226a7adcaa0f6ac4314c980568561727fe8adb03;
    uint256 constant pB_y1_PART1 = 0x000000000000000000000000000000000340304e51ee4e5eac0584008de96fed;
    uint256 constant pB_y1_PART2 = 0xc98c43ff84a1db5f46f783fa4b3986c8f1f50cf5b7a6031d6abfbdad9be9310f;

    uint256 constant pC_x_PART1 = 0x000000000000000000000000000000000ec43fc63089c2a31f37c0440cf03435;
    uint256 constant pC_x_PART2 = 0x0a3e66d477dd88c5a26193982aff587c7778640e3de2042864491b86a40f93e5;
    uint256 constant pC_y_PART1 = 0x00000000000000000000000000000000103e2efa463c48f4fa750c3285d7ddd6;
    uint256 constant pC_y_PART2 = 0xdf1fcb65adc5d4b00e1bb3af933a6e52a968c42ab962dd444023802196b51a36;

    function setUp() public {
        // Deploy IC constants contracts first
        icContract1 = new Groth16Verifier128LeavesIC1();
        icContract2 = new Groth16Verifier128LeavesIC2();
        // Deploy main verifier with IC contract addresses
        verifier = new Groth16Verifier128Leaves(address(icContract1), address(icContract2));
    }

    function testProof128() public view {
        // Proof data from proof.json
        uint256[4] memory proof_a = [pA_x_PART1, pA_x_PART2, pA_y_PART1, pA_y_PART2];

        uint256[8] memory proof_b =
            [pB_x0_PART1, pB_x0_PART2, pB_x1_PART1, pB_x1_PART2, pB_y0_PART1, pB_y0_PART2, pB_y1_PART1, pB_y1_PART2];

        uint256[4] memory proof_c = [pC_x_PART1, pC_x_PART2, pC_y_PART1, pC_y_PART2];

        // Public signals array with 257 elements from public.json
        uint256[257] memory pub_signals = [
            26975209276776476692791800104944319946909193252482610676888258047264401491067,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            5708510646087729135889959965248975632956651064800454628727069218571497917126,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            5708510646087729135889959965248975632956651064800454628727069218571497917126,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            5708510646087729135889959965248975632956651064800454628727069218571497917126,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            5708510646087729135889959965248975632956651064800454628727069218571497917126,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000
        ];

        // Verify with the proof data
        bool result = verifier.verifyProof(proof_a, proof_b, proof_c, pub_signals);

        console.log("128-leaf proof verification result:", result);
        assertTrue(result, "Proof should be valid");
    }
}



================================================
FILE: test/groth16/128_leaves/proof.json
================================================
{
 "pi_a": [
  "1141686076780515651615118164123075230248692211704850477776315045424309947224473381255864671171279851254383960796508",
  "1952593586738326781327797634990053743724320818660629462213792590937673299279646697531747239656315660615109984851541",
  "1"
 ],
 "pi_b": [
  [
   "1283220625572857136343214655155145228480394400141311213497024726422620416038178391386371752610106919508465283863205",
   "2211555106007980303195168497223852097906149833200955440759598630774475624675443683433249918164816675371059558248114"
  ],
  [
   "500334230341773862281426367188640596954801154554970842505422369797423391183613288858163922401860516206885844103439",
   "2458998131298292319636579161745884410100463371963820844105342032162449513408911356315046736871487380925763931527939"
  ],
  [
   "1",
   "0"
  ]
 ],
 "pi_c": [
  "2272787462871609760028048480461594698990509776957314159853048383802017273514346233073340629074236389980758516667365",
  "2500011784122817865966426433767557462493790917297649486327559452785369702013840870064254345922163030083609013066294",
  "1"
 ],
 "protocol": "groth16",
 "curve": "bls12381"
}


================================================
FILE: test/groth16/128_leaves/public.json
================================================
[
  "26975209276776476692791800104944319946909193252482610676888258047264401491067",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000"
]


================================================
FILE: test/groth16/16_leaves/Groth16Verifier16LeavesTest.t.sol
================================================
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../src/verifier/Groth16Verifier16Leaves.sol";

contract Groth16Verifier16LeavesTest is Test {
    Groth16Verifier16Leaves public verifier;

    // BLS12-381 proof constants from test/proof.json - split into PART1/PART2
    uint256 constant pA_x_PART1 = 0x000000000000000000000000000000001704850f141027d38db82f9a156aee28;
    uint256 constant pA_x_PART2 = 0xb3f725613a9e9a5d2aa5d464e4e6c1bd0a9de4947b9a04967abf26d0b3e10f3a;
    uint256 constant pA_y_PART1 = 0x0000000000000000000000000000000006325a7118ee745184433e60cb84ccbf;
    uint256 constant pA_y_PART2 = 0x515433e324e6d78350910475b1f94a486214996b07ac363314dd0c5b8c3aaa29;

    uint256 constant pB_x0_PART1 = 0x000000000000000000000000000000001332d8875c37890b2a86f0a0015bb523;
    uint256 constant pB_x0_PART2 = 0x94b2cd85dd4dce83ff30862f4f8903f876d245f4988e3bd92aae71838a2a0ae7;
    uint256 constant pB_x1_PART1 = 0x000000000000000000000000000000000f97e07d90a2a9c2a823923f235c0f61;
    uint256 constant pB_x1_PART2 = 0xcb1185cbbd8191cf2122505bee2f94c1ce2eb60d19d44e42f7bcfd45bb2904a9;

    uint256 constant pB_y0_PART1 = 0x00000000000000000000000000000000151f0eb1cdd70dbf4bc7405232abab0a;
    uint256 constant pB_y0_PART2 = 0xbba50119f06b18d96a700a92a4baf1f4e921cabae97160f1856f145aca288d2f;
    uint256 constant pB_y1_PART1 = 0x0000000000000000000000000000000004c1ecd4035c3ebc0fa9591fca69f94c;
    uint256 constant pB_y1_PART2 = 0xbe72adaeaedf3e8ea5219f1f4ea72764c49eb845cebb9e681c0abfb03b53152a;

    uint256 constant pC_x_PART1 = 0x00000000000000000000000000000000100ce14e889866d9d134118098a1728b;
    uint256 constant pC_x_PART2 = 0x69dcd611c3c32af5c09952256b83fd2ad85b7d4b446f14dc9cef9f0a9a3fa970;
    uint256 constant pC_y_PART1 = 0x000000000000000000000000000000000acc5d3f42b695721aca04114462d719;
    uint256 constant pC_y_PART2 = 0x9bbc7a5f23d3dfff777aa61408144a047e7795e1571f60b40257dfc92173494f;

    function setUp() public {
        verifier = new Groth16Verifier16Leaves();
    }

    function testValidProof16() public view {
        // Test data from test/proof.json and ../prover/16_leaves/public.json
        // This proof is generated for BLS12-381 curve with 16-leaf Merkle tree

        // pi_a - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pA = [pA_x_PART1, pA_x_PART2, pA_y_PART1, pA_y_PART2];

        // pi_b - G2 point (x0_PART1, x0_PART2, x1_PART1, x1_PART2, y0_PART1, y0_PART2, y1_PART1, y1_PART2)
        uint256[8] memory _pB =
            [pB_x0_PART1, pB_x0_PART2, pB_x1_PART1, pB_x1_PART2, pB_y0_PART1, pB_y0_PART2, pB_y1_PART1, pB_y1_PART2];

        // pi_c - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pC = [pC_x_PART1, pC_x_PART2, pC_y_PART1, pC_y_PART2];

        // Public signals from public.json (33 values for 16-leaf Merkle tree proof)
        uint256[33] memory _pubSignals = [
            uint256(8717996803693071601560617594908257064884645203109477683134260534252752083859),
            uint256(6218676549690402052910318315276979534381485872621884367715834658603456243904),
            uint256(0),
            uint256(0),
            uint256(5708510646087729135889959965248975632956651064800454628727069218571497917126),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(2000000000000000000000000000),
            uint256(0),
            uint256(0),
            uint256(1000000),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0)
        ];

        // Verify the proof
        bool result = verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        assertTrue(result, "Valid proof should pass verification");
    }

    function testGasConsumption16() public view {
        // Test data from test/proof.json and ../prover/16_leaves/public.json
        // This test measures gas consumption for BLS12-381 Groth16 verification

        // pi_a - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pA = [pA_x_PART1, pA_x_PART2, pA_y_PART1, pA_y_PART2];

        // pi_b - G2 point (x0_PART1, x0_PART2, x1_PART1, x1_PART2, y0_PART1, y0_PART2, y1_PART1, y1_PART2)
        uint256[8] memory _pB =
            [pB_x0_PART1, pB_x0_PART2, pB_x1_PART1, pB_x1_PART2, pB_y0_PART1, pB_y0_PART2, pB_y1_PART1, pB_y1_PART2];

        // pi_c - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pC = [pC_x_PART1, pC_x_PART2, pC_y_PART1, pC_y_PART2];

        // Public signals from public.json (33 values for 16-leaf Merkle tree proof)
        uint256[33] memory _pubSignals = [
            uint256(8717996803693071601560617594908257064884645203109477683134260534252752083859),
            uint256(6218676549690402052910318315276979534381485872621884367715834658603456243904),
            uint256(0),
            uint256(0),
            uint256(5708510646087729135889959965248975632956651064800454628727069218571497917126),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(2000000000000000000000000000),
            uint256(0),
            uint256(0),
            uint256(1000000),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0)
        ];

        // Measure gas consumption
        uint256 gasStart = gasleft();
        bool result = verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        uint256 gasEnd = gasleft();

        uint256 gasUsed = gasStart - gasEnd;

        // Log the gas consumption
        console.log("=== BLS12-381 Groth16 Verification Gas Report ===");
        console.log("Gas used for proof verification:", gasUsed);
        console.log("Proof verification result:", result ? "PASSED" : "FAILED");
        console.log("Circuit: 16-leaf Merkle tree");
        console.log("Public signals: 33");
        console.log("Curve: BLS12-381");
        console.log("Protocol: Groth16");

        // Assert the proof is valid
        assertTrue(result, "Valid proof should pass verification");
    }
}



================================================
FILE: test/groth16/16_leaves/proof.json
================================================
{
 "pi_a": [
  "3542741396304482615986524903929454638960341424374521416359268825957778616291270934031983959523679336794478440681274",
  "953758271674766532783308886372556810446844158487584184770398948677568855124613770557554490530148731879067638999593",
  "1"
 ],
 "pi_b": [
  [
   "2400023788120685775900292888371193300041474654050699474702695783847781209340034100046264277744563399016135434765481",
   "2954937519439967922194139383254431108210040268076091693705141221962939880989568290854600634078319447612653180685031"
  ],
  [
   "732249339805134858012376070910120084644835441827797426578962608908062019401167559203195117751768527524495875052842",
   "3250868365504523559501479623312381192011536555907774606832037075628285006746557217245546655666011310982013758508335"
  ],
  [
   "1",
   "0"
  ]
 ],
 "pi_c": [
  "2470369252636646841999893318459284852825574353930525847287092897605678970220440243932810376676327704442283940096368",
  "1662010149702018469708739319100206629240676413139159476042154217377086241634155167859385360194114661793677159123279",
  "1"
 ],
 "protocol": "groth16",
 "curve": "bls12381"
}


================================================
FILE: test/groth16/16_leaves/public.json
================================================
[
  "8717996803693071601560617594908257064884645203109477683134260534252752083859",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "0",
  "0",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "2000000000000000000000000000",
  "0",
  "0",
  "1000000",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0",
  "0"
]


================================================
FILE: test/groth16/32_leaves/Groth16Verifier32LeavesTest.t.sol
================================================
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../src/verifier/Groth16Verifier32Leaves.sol";

contract Groth16Verifier32LeavesTest is Test {
    Groth16Verifier32Leaves public verifier;

    // BLS12-381 proof constants from test/32_leaves/proof.json - split into PART1/PART2
    uint256 constant pA_x_PART1 = 0x00000000000000000000000000000000131e00eb6ba9a3b9fd61acdc9e909bcd;
    uint256 constant pA_x_PART2 = 0xc60795eb6d59149d688f21b2b9f3be63034b057564a3f80e17342caaecaa638e;
    uint256 constant pA_y_PART1 = 0x0000000000000000000000000000000004367b464c9d582ec6b7cd8abb043363;
    uint256 constant pA_y_PART2 = 0xc0f1b06b3b566865c1856588ebd94afd368759dbbd5b64f4d37371b0d495e320;

    //x1
    uint256 constant pB_x0_PART1 = 0x0000000000000000000000000000000010d7d41b359798150e7a63288de8b3f0;
    uint256 constant pB_x0_PART2 = 0xd3938e8d082993af469d2a37402e420ecfaf6d79aa1002ce45f8bb9b2c1582f9;
    //x0
    uint256 constant pB_x1_PART1 = 0x000000000000000000000000000000000c531036c339254e6b5864adbd3611e0;
    uint256 constant pB_x1_PART2 = 0x205a6380cd72fc618c91b86f69c52aaec4ebfe617e54f0c041b7356f3241e21c;

    //y0
    uint256 constant pB_y0_PART1 = 0x0000000000000000000000000000000003b0e7dca5b9a72192b5be190e7bfef9;
    uint256 constant pB_y0_PART2 = 0xc14311e988e898a61c766bfbb246272397770b7972dfee249b52ec4df74cb4c2;
    //y1
    uint256 constant pB_y1_PART1 = 0x00000000000000000000000000000000194cdf0b52d54d5b922950e2e1810b2c;
    uint256 constant pB_y1_PART2 = 0x7a15c5c06cc31adb37d34090f762ff7d925c0657b97d633945136dfe97bf4af7;

    uint256 constant pC_x_PART1 = 0x0000000000000000000000000000000004b3b2102a988de4a19aba67c15bad17;
    uint256 constant pC_x_PART2 = 0xdc415b7719d7c359b51a1f00c9fa19cfcd5baf26d6778131623772d790bd468a;
    uint256 constant pC_y_PART1 = 0x000000000000000000000000000000000ca6b8775b49dd6390acfe96969c8650;
    uint256 constant pC_y_PART2 = 0x39caa56372d4d490065d20c7f160d44fcadd8effb56aeaeb3d1973dc99a10d8b;

    function setUp() public {
        verifier = new Groth16Verifier32Leaves();
    }

    function testValidProof32() public view {
        // Test data from test/proof.json and ../prover/16_leaves/public.json
        // This proof is generated for BLS12-381 curve with 16-leaf Merkle tree

        // pi_a - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pA = [pA_x_PART1, pA_x_PART2, pA_y_PART1, pA_y_PART2];

        // pi_b - G2 point (x0_PART1, x0_PART2, x1_PART1, x1_PART2, y0_PART1, y0_PART2, y1_PART1, y1_PART2)
        uint256[8] memory _pB =
            [pB_x0_PART1, pB_x0_PART2, pB_x1_PART1, pB_x1_PART2, pB_y0_PART1, pB_y0_PART2, pB_y1_PART1, pB_y1_PART2];

        // pi_c - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pC = [pC_x_PART1, pC_x_PART2, pC_y_PART1, pC_y_PART2];

        // Public signals from test/32_leaves/public.json (65 values for 32-leaf Merkle tree proof)
        uint256[65] memory _pubSignals = [
            uint256(5895493230319637670729027073304946012562138136683578821957235132381685112735),
            uint256(6218676549690402052910318315276979534381485872621884367715834658603456243904),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(5708510646087729135889959965248975632956651064800454628727069218571497917126),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2000000000000000000000000000),
            uint256(20000000000000000000000000000),
            uint256(20000000000000000000000000000),
            uint256(1000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000)
        ];

        // Verify the proof
        bool result = verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        assertTrue(result, "Valid proof should pass verification");
    }

    function testGasConsumption32() public view {
        // Test data from test/32_leaves/proof.json and test/32_leaves/public.json
        // This test measures gas consumption for BLS12-381 Groth16 verification

        // pi_a - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pA = [pA_x_PART1, pA_x_PART2, pA_y_PART1, pA_y_PART2];

        // pi_b - G2 point (x0_PART1, x0_PART2, x1_PART1, x1_PART2, y0_PART1, y0_PART2, y1_PART1, y1_PART2)
        uint256[8] memory _pB =
            [pB_x0_PART1, pB_x0_PART2, pB_x1_PART1, pB_x1_PART2, pB_y0_PART1, pB_y0_PART2, pB_y1_PART1, pB_y1_PART2];

        // pi_c - G1 point (x_PART1, x_PART2, y_PART1, y_PART2)
        uint256[4] memory _pC = [pC_x_PART1, pC_x_PART2, pC_y_PART1, pC_y_PART2];

        // Public signals from test/32_leaves/public.json (65 values for 32-leaf Merkle tree proof)
        uint256[65] memory _pubSignals = [
            uint256(5895493230319637670729027073304946012562138136683578821957235132381685112735),
            uint256(6218676549690402052910318315276979534381485872621884367715834658603456243904),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(5708510646087729135889959965248975632956651064800454628727069218571497917126),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2186765496904020529103183152769795343814858726218843677158346586034562439040),
            uint256(2000000000000000000000000000),
            uint256(20000000000000000000000000000),
            uint256(20000000000000000000000000000),
            uint256(1000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(10000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(200000000000000000000000000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(100000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000),
            uint256(2000000000000000000000000000000)
        ];

        // Measure gas consumption
        uint256 gasStart = gasleft();
        bool result = verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        uint256 gasEnd = gasleft();

        uint256 gasUsed = gasStart - gasEnd;

        // Log the gas consumption
        console.log("=== BLS12-381 Groth16 Verification Gas Report ===");
        console.log("Gas used for proof verification:", gasUsed);
        console.log("Proof verification result:", result ? "PASSED" : "FAILED");
        console.log("Circuit: 32-leaf Merkle tree");
        console.log("Public signals: 65");
        console.log("Curve: BLS12-381");
        console.log("Protocol: Groth16");

        // Assert the proof is valid
        assertTrue(result, "Valid proof should pass verification");
    }
}



================================================
FILE: test/groth16/32_leaves/proof.json
================================================
{
 "pi_a": [
  "2942406614171244654080176976675034820726108047050664088731628320171911275761123580709945755768899020962089283511182",
  "648412115145778188141479423907310872225212083379719460662319298051288730777968209193207396081095013546882544034592",
  "1"
 ],
 "pi_b": [
  [
   "1896908952327798142499475833126384984940362847955123673346133267426408637720715720507675617983285259637123128091164",
   "2592387311676449604077664058324966710129829205405883260321389991571364705679775720017594736805936788234846501962489"
  ],
  [
   "3894069240985397732017228793943890743635156726683239535063683023414916871321553984057966110107804346170764720818935",
   "568102732277773017283525544551384763855624811083203607714134814598441507044050956735192455505066248954290706887874"
  ],
  [
   "1",
   "0"
  ]
 ],
 "pi_c": [
  "723694151021800667941453577301986232023947119857881530339324558643150724228674628294743122176408670755737778865802",
  "1947205932865527864785403586726753321605458218239247892659151489328932785176771228973870581788584095522535357091211",
  "1"
 ],
 "protocol": "groth16",
 "curve": "bls12381"
}


================================================
FILE: test/groth16/32_leaves/public.json
================================================
[
  "5895493230319637670729027073304946012562138136683578821957235132381685112735",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2186765496904020529103183152769795343814858726218843677158346586034562439040",
  "2000000000000000000000000000",
  "20000000000000000000000000000",
  "20000000000000000000000000000",
  "1000000",
  "10000000",
  "10000000",
  "10000000",
  "10000000",
  "10000000",
  "10000000",
  "10000000",
  "200000000000000000000000000000",
  "200000000000000000000000000000",
  "200000000000000000000000000000",
  "200000000000000000000000000000",
  "200000000000000000000000000000",
  "100000000",
  "100000000",
  "100000000",
  "100000000",
  "100000000",
  "100000000",
  "100000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000",
  "2000000000000000000000000000000"
]


================================================
FILE: test/groth16/64_leaves/Groth16Verifier64LeavesTest.t.sol
================================================
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../src/verifier/Groth16Verifier64Leaves.sol";
import "../../../src/verifier/Groth16Verifier64LeavesIC.sol";

contract Groth16Verifier64LeavesNewProofTest is Test {
    Groth16Verifier64Leaves verifier;
    Groth16Verifier64LeavesIC icContract;

    // Updated BLS12-381 proof constants from new proof.json - split into PART1/PART2
    uint256 constant pA_x_PART1 = 0x000000000000000000000000000000000c2c7403abb0d7f9774667af73c84cbe;
    uint256 constant pA_x_PART2 = 0x6d615eec6620e135cf3764a2b798e37c39f3449c5c67cf1ee1adb82e1984696a;
    uint256 constant pA_y_PART1 = 0x0000000000000000000000000000000014104f1ea260fd94e9e946275fd78bee;
    uint256 constant pA_y_PART2 = 0xc85653aed170fa0c8f259a3b34a4624150a85bc817febfa3f251da31558fe519;

    //x0
    uint256 constant pB_x0_PART1 = 0x00000000000000000000000000000000052c670ce3848f29d28fc43e806e00f8;
    uint256 constant pB_x0_PART2 = 0x6294d7a1f647a55f539228dabe12a1b6e2cd53274196e66a097220327b34537f;
    //x1
    uint256 constant pB_x1_PART1 = 0x000000000000000000000000000000001260199a730516c11d484d418bdf4280;
    uint256 constant pB_x1_PART2 = 0xbc886344866cc0ec0d9bd280480f4e0c4cb717dc61832cd6f2115cd9db6bfe2d;
    //y0
    uint256 constant pB_y0_PART1 = 0x00000000000000000000000000000000154c003d4c9b7fd20b6fdbc5e9a561b0;
    uint256 constant pB_y0_PART2 = 0x8bfe6767182b7d908be77400691a3037687b62b2eac3f0734ed0e2dc20978ddb;
    //y1
    uint256 constant pB_y1_PART1 = 0x00000000000000000000000000000000108cd334783e96f5f7f0b39fedc77592;
    uint256 constant pB_y1_PART2 = 0xb1642e9ea4d6bddd02c076903c77f70d854222c53e89c83da3b4b7fc31271c5e;

    uint256 constant pC_x_PART1 = 0x000000000000000000000000000000001641171bf90e5d5fa491c2a8581c6c72;
    uint256 constant pC_x_PART2 = 0x9da24b959702f23f66531cbc4c1cb2f8316146e168997e4b56c3cf272ed3116d;
    uint256 constant pC_y_PART1 = 0x00000000000000000000000000000000068a4ddcf98e105f28eaff2b8e6143ca;
    uint256 constant pC_y_PART2 = 0xd325622716af87dee0eb2e0a1fce70b0b95f6a046e0b6fca6bb1082a6be3489f;

    function setUp() public {
        // Deploy IC constants contract first
        icContract = new Groth16Verifier64LeavesIC();
        // Deploy main verifier with IC contract address
        verifier = new Groth16Verifier64Leaves(address(icContract));
    }

    function testVerifyProof64() public view {
        // New proof data from updated proof.json
        uint256[4] memory proof_a = [pA_x_PART1, pA_x_PART2, pA_y_PART1, pA_y_PART2];

        uint256[8] memory proof_b =
            [pB_x0_PART1, pB_x0_PART2, pB_x1_PART1, pB_x1_PART2, pB_y0_PART1, pB_y0_PART2, pB_y1_PART1, pB_y1_PART2];

        uint256[4] memory proof_c = [pC_x_PART1, pC_x_PART2, pC_y_PART1, pC_y_PART2];

        // Updated public signals array with 129 elements from new public.json
        uint256[129] memory pub_signals = [
            50803289751659168012871184753748907509578899911239403202058491060091161856746,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            5708510646087729135889959965248975632956651064800454628727069218571497917126,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            6218676549690402052910318315276979534381485872621884367715834658603456243904,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            5708510646087729135889959965248975632956651064800454628727069218571497917126,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            123456789123456789123456789123456789123456789123456789123456789123456789,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000,
            2000000000000000000000000000
        ];

        // Verify with new proof data
        bool result = verifier.verifyProof(proof_a, proof_b, proof_c, pub_signals);

        console.log("New 64-leaf proof verification result:", result);
        assertTrue(result, "New proof should be valid");
    }
}



================================================
FILE: test/groth16/64_leaves/proof.json
================================================
{
 "pi_a": [
  "1873695488722637731434672535512330882261963926449420789353974556695082025618492073858234165217768828560029121800554",
  "3088087180415228862858364115837324242758971365881541383387588484650037395869264815768227574071074119764284699305241",
  "1"
 ],
 "pi_b": [
  [
   "2828231473679796028944628604702381373598378186792298270900514172205226549699986020626951501088001384653264899538477",
   "796266435302962483198171116626348281107531275574248352265986394156190435994081114781437947510369179828291414283135"
  ],
  [
   "2547293177283018001546023154175653877238924695566802852791662156772821156361925219316313237895513024271417384311902",
   "3277889627647391651282804827293875941914610538263267867942053769957308711388656554617990517693822777488540901543387"
  ],
  [
   "1",
   "0"
  ]
 ],
 "pi_c": [
  "3425243929182415354666290249952452881230250744847698834702138232049963365599166481265006389320820155698214065082733",
  "1006636697592914982920421936142940549814453672080725970635456858107117445441181100796852822457040155434727973800095",
  "1"
 ],
 "protocol": "groth16",
 "curve": "bls12381"
}


================================================
FILE: test/groth16/64_leaves/public.json
================================================
[
  "50803289751659168012871184753748907509578899911239403202058491060091161856746",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "6218676549690402052910318315276979534381485872621884367715834658603456243904",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "5708510646087729135889959965248975632956651064800454628727069218571497917126",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "123456789123456789123456789123456789123456789123456789123456789123456789",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000",
  "2000000000000000000000000000"
]


================================================
FILE: test/js-scripts/generate_proof.sh
================================================
#!/bin/bash

# Script to generate Groth16 proofs for testing
# Usage: ./generate_proof.sh [mpt_key1] [balance1] [mpt_key2] [balance2] [mpt_key3] [balance3]

# Default test values if no arguments provided
if [ $# -eq 0 ]; then
    echo "Using default test values..."
    MPT_KEY1="1461501637330902918203684832716283019655932542976"  # uint160 of address(0xd69B7AaaE8C1c9F0546AfA4Fd8eD39741cE3f59F)
    BALANCE1="1000000000000000000"  # 1 ETH
    MPT_KEY2="1240746827509629851092253602051341618533"  # uint160 of address(0xb18E7CdB6Aa28Cc645227041329896446A1478bd)
    BALANCE2="2000000000000000000"  # 2 ETH
    MPT_KEY3="1033628234203421458715762354672"  # uint160 of address(0x9D70617FF571Ac34516C610a51023EE1F28373e8)
    BALANCE3="3000000000000000000"  # 3 ETH
else
    MPT_KEY1=$1
    BALANCE1=$2
    MPT_KEY2=$3
    BALANCE2=$4
    MPT_KEY3=$5
    BALANCE3=$6
fi

echo "Generating Groth16 proof with:"
echo "Participant 1: MPT Key = $MPT_KEY1, Balance = $BALANCE1"
echo "Participant 2: MPT Key = $MPT_KEY2, Balance = $BALANCE2"  
echo "Participant 3: MPT Key = $MPT_KEY3, Balance = $BALANCE3"

# Change to the project root directory
cd "$(dirname "$0")/../.."

# Run the Node.js script
node test/js-scripts/generateGroth16Proof.js $MPT_KEY1 $BALANCE1 $MPT_KEY2 $BALANCE2 $MPT_KEY3 $BALANCE3


================================================
FILE: test/js-scripts/generateGroth16Proof.js
================================================
#!/usr/bin/env node

import snarkjs from "snarkjs";
import fs from "fs";
import path from "path";
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Script to generate Groth16 proofs for testing the RollupBridge contract
 * Usage: node generateGroth16Proof.js [participant1_mpt_key] [participant1_balance] [participant2_mpt_key] [participant2_balance] [participant3_mpt_key] [participant3_balance]
 * Example: node generateGroth16Proof.js 1461501637330902918203684832716283019655932542976 1000000000000000000 1240746827509629851092253602051341618533 2000000000000000000 1033628234203421458715762354672 3000000000000000000
 */

async function generateProof() {
    const args = process.argv.slice(2);
    
    if (args.length < 6) {
        console.log("Usage: node generateGroth16Proof.js [mpt_key1] [balance1] [mpt_key2] [balance2] [mpt_key3] [balance3]");
        console.log("Example: node generateGroth16Proof.js 1461501637330902918203684832716283019655932542976 1000000000000000000 1240746827509629851092253602051341618533 2000000000000000000 1033628234203421458715762354672 3000000000000000000");
        process.exit(1);
    }

    // Parse arguments
    const participants = [];
    for (let i = 0; i < 6; i += 2) {
        participants.push({
            mptKey: args[i],
            balance: args[i + 1]
        });
    }

    // Build input for the circuit
    const input = {
        merkle_keys: new Array(50).fill("0"),
        storage_values: new Array(50).fill("0")
    };

    // Fill in the actual participant data
    for (let i = 0; i < participants.length; i++) {
        input.merkle_keys[i] = participants[i].mptKey;
        input.storage_values[i] = participants[i].balance;
    }

    // Paths to circuit files
    const circuitWasm = path.join(__dirname, "../../groth16/circuits/build/merkle_tree_circuit_js/merkle_tree_circuit.wasm");
    const circuitZkey = path.join(__dirname, "../../groth16/trusted-setup/merkle_tree_circuit_final.zkey");

    try {
        console.log("Generating witness...");
        console.log("Input:", JSON.stringify(input, null, 2));

        // Check if circuit files exist
        if (!fs.existsSync(circuitWasm)) {
            throw new Error(`Circuit WASM file not found at: ${circuitWasm}`);
        }
        if (!fs.existsSync(circuitZkey)) {
            throw new Error(`Circuit zkey file not found at: ${circuitZkey}`);
        }

        // Generate witness
        const { witness } = await snarkjs.wtns.calculate(input, circuitWasm);

        console.log("Generating proof...");
        
        // Generate the proof
        const { proof, publicSignals } = await snarkjs.groth16.prove(circuitZkey, witness);

        console.log("\\n=== GENERATED PROOF ===");
        console.log("Proof A:", [proof.pi_a[0], proof.pi_a[1]]);
        console.log("Proof B:", [[proof.pi_b[0][1], proof.pi_b[0][0]], [proof.pi_b[1][1], proof.pi_b[1][0]]]);
        console.log("Proof C:", [proof.pi_c[0], proof.pi_c[1]]);
        console.log("Public signals (first 10):", publicSignals.slice(0, 10));
        console.log("Merkle root (last signal):", publicSignals[publicSignals.length - 1]);

        // Format for Solidity test
        console.log("\\n=== SOLIDITY TEST FORMAT ===");
        console.log(`uint[2] memory pA = [uint(${proof.pi_a[0]}), uint(${proof.pi_a[1]})];`);
        console.log(`uint[2][2] memory pB = [[uint(${proof.pi_b[0][1]}), uint(${proof.pi_b[0][0]})], [uint(${proof.pi_b[1][1]}), uint(${proof.pi_b[1][0]})]];`);
        console.log(`uint[2] memory pC = [uint(${proof.pi_c[0]}), uint(${proof.pi_c[1]})];`);
        console.log(`bytes32 merkleRoot = bytes32(uint256(${publicSignals[publicSignals.length - 1]}));`);

        // Save to files
        const outputDir = path.join(__dirname, "../proof-outputs");
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        fs.writeFileSync(path.join(outputDir, "proof.json"), JSON.stringify(proof, null, 2));
        fs.writeFileSync(path.join(outputDir, "public.json"), JSON.stringify(publicSignals, null, 2));
        fs.writeFileSync(path.join(outputDir, "input.json"), JSON.stringify(input, null, 2));

        console.log(`\\nFiles saved to: ${outputDir}`);

        // Verify the proof
        const verificationKey = JSON.parse(fs.readFileSync(path.join(__dirname, "../../groth16/trusted-setup/verification_key.json")));
        const isValid = await snarkjs.groth16.verify(verificationKey, publicSignals, proof);
        console.log("\\nProof verification:", isValid ? "✓ VALID" : "✗ INVALID");

    } catch (error) {
        console.error("Error generating proof:", error);
        process.exit(1);
    }
}

// Run the script
generateProof().catch(console.error);


================================================
FILE: test/js-scripts/generateProof.js
================================================
import { SimpleQuaternaryTree } from "./simpleQuaternaryTree.js";
import { computeLeaf } from "./merkleTree.js";

/**
 * Generate merkle proof for a specific user's withdrawal - SIMPLIFIED INTERFACE
 * 
 * Usage: node generateProofSimple.js <channelId> <userL2Address> <finalStateRoot>
 * 
 * This version uses a much simpler interface by hardcoding the test participant data.
 * For production, participant data would come from the contract or be passed differently.
 */

function generateWithdrawalProof() {
  const inputs = process.argv.slice(2);
  
  // Check if we're in quiet mode for FFI
  const isQuiet = process.env.FFI_MODE === 'true' || process.argv.includes('--ffi');

  if (inputs.length !== 3) {
    if (!isQuiet) {
      console.error(`Expected 3 arguments, got ${inputs.length}`);
      console.error('Usage: node generateProofSimple.js <channelId> <userL2Address> <finalStateRoot>');
      console.error('Example: node generateProofSimple.js 0 0xd69B7AaaE8C1c9F0546AfA4Fd8eD39741cE3f59F 0x123...');
    }
    process.exit(1);
  }

  // Parse inputs
  const channelId = inputs[0];
  const userL2Address = inputs[1];
  const finalStateRoot = inputs[2];

  // Hardcoded test participant data (in a real implementation, this would come from the contract)
  const participantsData = [
    {
      participantRoot: "0x8449acb4300b58b00e4852ab07d43f298eaa35688eaa3917ca205f20e6db73e8",
      l2Address: "0xd69B7AaaE8C1c9F0546AfA4Fd8eD39741cE3f59F", // participant1
      balance: "1000000000000000000"
    },
    {
      participantRoot: "0x3bec727653ae8d56ac6d9c103182ff799fe0a3b512e9840f397f0d21848373e8", 
      l2Address: "0xb18E7CdB6Aa28Cc645227041329896446A1478bd", // participant2
      balance: "1000000000000000000"
    },
    {
      participantRoot: "0x11e1e541a59fb2cd7fa4371d63103972695ee4bb4d1e646e72427cf6cdc16498",
      l2Address: "0x9D70617FF571Ac34516C610a51023EE1F28373e8", // participant3
      balance: "1000000000000000000"
    }
  ];

  if (!isQuiet) {
    console.log(`Generating withdrawal proof for:`);
    console.log(`- Channel ID: ${channelId}`);
    console.log(`- User L2 Address: ${userL2Address}`);
    console.log(`- Final State Root: ${finalStateRoot}`);
    console.log(`- Total participants: ${participantsData.length}`);
  }

  try {
    // Find user's index in participants data
    let userLeafIndex = -1;
    let userParticipantRoot = null;
    let userBalance = null;
    
    for (let i = 0; i < participantsData.length; i++) {
      const participant = participantsData[i];
      if (participant.l2Address.toLowerCase() === userL2Address.toLowerCase()) {
        userLeafIndex = i;
        userParticipantRoot = participant.participantRoot;
        userBalance = participant.balance;
        if (!isQuiet) console.log(`\nFound user at index ${i} with balance ${userBalance}`);
        break;
      }
    }
    
    if (userLeafIndex === -1) {
      throw new Error(`User's L2 address ${userL2Address} not found in participants data`);
    }

    // Build the final state tree with individual participant roots
    if (!isQuiet) console.log(`\nStep 1: Building tree with individual participant roots...`);
    
    const tree = new SimpleQuaternaryTree(3);
    const leaves = [];
    
    for (const { participantRoot, l2Address, balance } of participantsData) {
      const leaf = computeLeaf(participantRoot, l2Address, balance);
      leaves.push(leaf);
    }
    
    tree.insertAll(leaves);
    const computedTreeRoot = tree.root();
    
    if (!isQuiet) {
      console.log(`Computed tree root: ${computedTreeRoot}`);
      console.log(`Expected finalStateRoot: ${finalStateRoot}`);
      console.log(`Tree root matches finalStateRoot: ${computedTreeRoot === finalStateRoot ? 'YES' : 'NO'}`);
    }
    
    // Compute user's leaf exactly like the contract does during withdrawal  
    const userLeafValue = computeLeaf(userParticipantRoot, userL2Address, userBalance);
    if (!isQuiet) console.log(`\nUser's withdrawal leaf: ${userLeafValue} at index ${userLeafIndex}`);
    
    // Generate merkle proof for the user's specific leaf
    const proofData = tree.proof(userLeafIndex);
    if (!isQuiet) {
      console.log(`\nGenerating proof for user's leaf at index: ${userLeafIndex}`);
      console.log(`Merkle proof has ${proofData.pathElements.length} elements`);
    }
    
    // Verify our proof locally
    const isValid = tree.verifyProof(userLeafIndex, userLeafValue, proofData.pathElements);
    if (!isQuiet) console.log(`\n✓ Proof verification: ${isValid ? 'PASSED' : 'FAILED'}`);
    
    if (!isValid) {
      throw new Error('Generated proof failed local verification');
    }

    const result = {
      channelId,
      claimedBalance: userBalance, 
      leafIndex: userLeafIndex,
      merkleProof: proofData.pathElements,
      leafValue: userLeafValue,
      userL2Address,
      computedTreeRoot,
      expectedFinalRoot: finalStateRoot
    };

    return result;

  } catch (error) {
    if (!isQuiet) console.error('\n❌ Proof generation failed:', error);
    throw error;
  }
}

// Main execution
if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    const proofData = generateWithdrawalProof();
    
    // Check if we're running in FFI mode (suppress logs for Foundry)
    const isFFIMode = process.env.FFI_MODE === 'true' || process.argv.includes('--ffi');
    
    if (isFFIMode) {
      // Output simple format for FFI parsing: channelId,claimedBalance,leafIndex,proof1,proof2,...
      console.log(`${proofData.channelId},${proofData.claimedBalance},${proofData.leafIndex},${proofData.merkleProof.join(',')}`);
    } else {
      // Human-readable output
      console.log('\n✅ Withdrawal proof generated successfully!');
      console.log('\n📋 Proof Data for withdraw:');
      console.log(`channelId: ${proofData.channelId}`);
      console.log(`claimedBalance: ${proofData.claimedBalance}`);
      console.log(`leafIndex: ${proofData.leafIndex}`);
      console.log(`merkleProof: [${proofData.merkleProof.map(p => `"${p}"`).join(', ')}]`);
      
      console.log('\n🔧 Smart Contract Call:');
      console.log('withdraw(');
      console.log(`  ${proofData.channelId}, // channelId`);
      console.log(`  ${proofData.claimedBalance}, // claimedBalance`);
      console.log(`  ${proofData.leafIndex}, // leafIndex`);
      console.log(`  [${proofData.merkleProof.map(p => `"${p}"`).join(', ')}] // merkleProof`);
      console.log(')');
      
      // Also output as JSON for programmatic use
      console.log('\n📄 JSON Output:');
      console.log(JSON.stringify(proofData, null, 2));
    }
    
  } catch (error) {
    if (process.env.FFI_MODE === 'true' || process.argv.includes('--ffi')) {
      // In FFI mode, output error in a way that won't break parsing
      console.error(JSON.stringify({error: error.message}));
    } else {
      console.error('Script failed:', error);
    }
    process.exit(1);
  }
}

export default generateWithdrawalProof;


================================================
FILE: test/js-scripts/merkleTree.js
================================================
import { ethers } from 'ethers';

function hashFour(a, b, c, d) {
  return ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
    ['bytes32', 'bytes32', 'bytes32', 'bytes32'],
    [a, b, c, d]
  ));
}

function computeZeros(level) {
  let zero = ethers.ZeroHash;
  for (let i = 0; i < level; i++) {
    zero = hashFour(zero, zero, zero, zero);
  }
  return zero;
}

export class QuaternaryTree {
  constructor(depth) {
    this.depth = depth;
    this.storage = new Map();
    this.cachedSubtrees = new Map();
    this.nextLeafIndex = 0;
    this.roots = []; // Track all roots like the contract
    this.currentRootIndex = 0;
    
    // Pre-compute zero values for each level
    this.zeros = [];
    for (let level = 0; level <= depth; level++) {
      this.zeros[level] = computeZeros(level);
    }
  }

  init() {
    // Initialize empty tree with zero subtrees cached
    for (let level = 0; level <= this.depth; level++) {
      this.cachedSubtrees.set(this.levelToKey(level), this.zeros[level]);
    }
    
    // Set initial root (matching contract's initializeChannelState)
    const initialRoot = this.zeros[this.depth];
    this.roots.push(initialRoot);
    this.currentRootIndex = 0;
  }

  levelToKey(level) {
    return `level-${level}`;
  }

  static indexToKey(level, index) {
    return `${level}-${index}`;
  }

  getIndex(leaf) {
    for (const [key, value] of this.storage.entries()) {
      if (value === leaf && key.startsWith('0-')) {
        return parseInt(key.split('-')[1]);
      }
    }
    return -1;
  }

  root() {
    return this.roots[this.currentRootIndex] || this.zeros[this.depth];
  }
  
  getCurrentRoot() {
    return this.roots[this.currentRootIndex] || this.zeros[this.depth];
  }
  
  getLastRootInSequence() {
    return this.roots[this.roots.length - 1] || this.zeros[this.depth];
  }

  proof(index) {
    const leaf = this.storage.get(QuaternaryTree.indexToKey(0, index));
    if (!leaf) throw new Error("leaf not found");

    const pathElements = [];
    let currentIndex = index;

    for (let level = 0; level < this.depth; level++) {
      const childIndex = currentIndex % 4;
      
      // Get the 3 siblings needed for quaternary proof
      // We need to get actual stored values from the tree
      for (let i = 0; i < 4; i++) {
        if (i !== childIndex) {
          const siblingIndex = Math.floor(currentIndex / 4) * 4 + i;
          let sibling;
          
          // Check if this sibling exists in storage at level 0 (leaves)
          if (level === 0) {
            sibling = this.storage.get(QuaternaryTree.indexToKey(0, siblingIndex)) || this.zeros[level];
          } else {
            // For higher levels, we need to compute what the sibling would be
            // This is complex because the tree uses cached subtrees logic
            // For now, use zero as placeholder - this needs proper implementation
            sibling = this.zeros[level];
          }
          pathElements.push(sibling);
        }
      }
      
      currentIndex = Math.floor(currentIndex / 4);
    }

    return {
      root: this.root(),
      pathElements,
      childIndex: index % 4,
      leaf,
    };
  }

  insert(leaf) {
    const index = this.nextLeafIndex;
    this.update(index, leaf, true);
    this.nextLeafIndex++;
  }

  update(index, newLeaf, isInsert = false) {
    if (!isInsert && index >= this.nextLeafIndex) {
      throw Error("Use insert method for new elements.");
    } else if (isInsert && index < this.nextLeafIndex) {
      throw Error("Use update method for existing elements.");
    }

    // Check if tree is full
    const maxLeaves = 4 ** this.depth;
    if (index >= maxLeaves) {
      throw Error("MerkleTreeFull");
    }

    // Store the leaf
    this.storage.set(QuaternaryTree.indexToKey(0, index), newLeaf);

    // Update the cached subtrees and compute new root (matching contract exactly)
    let currentHash = newLeaf;
    let currentIndex = index;

    for (let level = 0; level < this.depth; level++) {
      if (currentIndex % 4 === 0) {
        // This is a leftmost node, cache it
        this.cachedSubtrees.set(this.levelToKey(level), currentHash);
        break;
      } else {
        // Compute parent hash using 4 children (matching contract _insertLeaf)
        const left = this.cachedSubtrees.get(this.levelToKey(level)) || this.zeros[level];
        const child2 = currentIndex % 4 >= 2 ? currentHash : ethers.ZeroHash;
        const child3 = currentIndex % 4 === 3 ? currentHash : ethers.ZeroHash;
        const child4 = ethers.ZeroHash;

        currentHash = hashFour(left, child2, child3, child4);
        currentIndex = Math.floor(currentIndex / 4);
      }
    }

    // Update tree state (matching contract)
    if (isInsert) {
      this.nextLeafIndex = index + 1;
    }

    // Store new root (matching contract)
    this.currentRootIndex += 1;
    this.roots.push(currentHash);
    this.storage.set(QuaternaryTree.indexToKey(this.depth, 0), currentHash);
  }

  traverse(index, fn) {
    let currentIndex = index;
    for (let level = 0; level < this.depth; level++) {
      fn(level, currentIndex);
      currentIndex = Math.floor(currentIndex / 4);
    }
  }
}


// Build tree exactly like contract does during initializeChannelState
export function buildInitialStateTree(channelId, participants) {
  const TREE_DEPTH = 3;
  const tree = new QuaternaryTree(TREE_DEPTH);
  tree.init();
  
  let nonce = 0;
  
  // Insert leaves sequentially like the contract does
  for (let i = 0; i < participants.length; i++) {
    const { l2Address, balance } = participants[i];
    
    // Compute prevRoot based on current nonce (matching contract logic)
    let prevRoot;
    if (nonce === 0) {
      prevRoot = ethers.zeroPadValue(ethers.toBeHex(BigInt(channelId)), 32);
    } else {
      prevRoot = tree.getLastRootInSequence();
    }
    
    // Compute leaf with current prevRoot
    const leaf = computeLeaf(prevRoot, l2Address, balance);
    
    // Insert leaf (this updates the tree and creates a new root)
    tree.insert(leaf);
    
    nonce++;
  }
  
  return tree;
}

// Build final state tree where all participants use the same prevRoot
export function buildFinalStateTree(finalStateRoot, participants) {
  const TREE_DEPTH = 3;
  const tree = new QuaternaryTree(TREE_DEPTH);
  tree.init();
  
  // In final state, ALL participants use the same prevRoot (finalStateRoot)
  const leaves = [];
  for (const { l2Address, balance } of participants) {
    const leaf = computeLeaf(finalStateRoot, l2Address, balance);
    leaves.push(leaf);
  }
  
  // Insert all leaves at once
  for (const leaf of leaves) {
    tree.insert(leaf);
  }
  
  return tree;
}

// Build final state tree where each participant uses their individual prevRoot
export function buildFinalStateTreeWithIndividualRoots(participants) {
  const TREE_DEPTH = 3;
  const tree = new QuaternaryTree(TREE_DEPTH);
  tree.init();
  
  // Each participant uses their specific prevRoot
  const leaves = [];
  for (const { participantRoot, l2Address, balance } of participants) {
    const leaf = computeLeaf(participantRoot, l2Address, balance);
    leaves.push(leaf);
  }
  
  // Insert all leaves at once
  for (const leaf of leaves) {
    tree.insert(leaf);
  }
  
  return tree;
}

// Legacy function for backward compatibility
export function merkleTree(leaves) {
  const TREE_DEPTH = 3;
  const tree = new QuaternaryTree(TREE_DEPTH);
  tree.init();
  
  for (const leaf of leaves) {
    tree.insert(leaf);
  }
  
  return tree;
}

// Helper function to compute leaf like the contract does
export function computeLeaf(prevRoot, l2Address, balance) {
  // RLC computation matching contract's _computeLeafPure
  // Use abi.encodePacked (like the contract) instead of abi.encode
  const l2AddressBytes32 = ethers.zeroPadValue(ethers.toBeHex(BigInt(l2Address)), 32);
  const packedData = ethers.concat([prevRoot, l2AddressBytes32]);
  const gamma = ethers.keccak256(packedData);
  
  // RLC formula: l2Address + gamma * balance
  const leafValue = (BigInt(l2Address) + BigInt(gamma) * BigInt(balance)) % (2n ** 256n);
  return ethers.zeroPadValue(ethers.toBeHex(leafValue), 32);
}



================================================
FILE: test/js-scripts/simpleQuaternaryTree.js
================================================
import { ethers } from "ethers";

// Simple quaternary tree implementation for proof generation
export class SimpleQuaternaryTree {
  constructor(depth = 3) {
    this.depth = depth;
    this.maxLeaves = 4 ** depth;
    this.leaves = new Array(this.maxLeaves).fill(ethers.ZeroHash);
    this.tree = {}; // Store all nodes: tree[level][index] = hash
    
    // Initialize tree structure
    for (let level = 0; level <= depth; level++) {
      this.tree[level] = {};
    }
  }

  insert(index, leaf) {
    if (index >= this.maxLeaves) throw new Error("Index out of bounds");
    
    this.leaves[index] = leaf;
    this.tree[0][index] = leaf;
    
    // Rebuild the entire tree (simple but correct approach)
    this.rebuild();
  }

  insertAll(leaves) {
    for (let i = 0; i < leaves.length; i++) {
      if (i >= this.maxLeaves) break;
      this.leaves[i] = leaves[i];
      this.tree[0][i] = leaves[i];
    }
    this.rebuild();
  }

  rebuild() {
    // Build tree level by level
    for (let level = 1; level <= this.depth; level++) {
      const nodesInLevel = 4 ** (this.depth - level);
      
      for (let nodeIndex = 0; nodeIndex < nodesInLevel; nodeIndex++) {
        // Each node at this level is computed from 4 children at previous level
        const childBaseIndex = nodeIndex * 4;
        const prevLevel = level - 1;
        
        const child0 = this.tree[prevLevel][childBaseIndex] || ethers.ZeroHash;
        const child1 = this.tree[prevLevel][childBaseIndex + 1] || ethers.ZeroHash;
        const child2 = this.tree[prevLevel][childBaseIndex + 2] || ethers.ZeroHash;
        const child3 = this.tree[prevLevel][childBaseIndex + 3] || ethers.ZeroHash;
        
        this.tree[level][nodeIndex] = this.hashFour(child0, child1, child2, child3);
      }
    }
  }

  hashFour(a, b, c, d) {
    const packed = ethers.solidityPacked(["bytes32", "bytes32", "bytes32", "bytes32"], [a, b, c, d]);
    return ethers.keccak256(packed);
  }

  root() {
    return this.tree[this.depth][0] || ethers.ZeroHash;
  }

  proof(leafIndex) {
    if (leafIndex >= this.maxLeaves) throw new Error("Leaf index out of bounds");
    
    const pathElements = [];
    let currentIndex = leafIndex;
    
    for (let level = 0; level < this.depth; level++) {
      const childIndex = currentIndex % 4;
      const siblingBaseIndex = Math.floor(currentIndex / 4) * 4;
      
      // Add the 3 siblings (in order, excluding the child)
      for (let i = 0; i < 4; i++) {
        if (i !== childIndex) {
          const sibling = this.tree[level][siblingBaseIndex + i] || ethers.ZeroHash;
          pathElements.push(sibling);
        }
      }
      
      currentIndex = Math.floor(currentIndex / 4);
    }

    return {
      pathElements,
      leafIndex,
      leaf: this.tree[0][leafIndex]
    };
  }

  // Verify proof manually (for testing)
  verifyProof(leafIndex, leaf, proof) {
    let computedHash = leaf;
    let index = leafIndex;
    let proofIndex = 0;

    for (let level = 0; level < this.depth; level++) {
      const childIndex = index % 4;

      if (childIndex === 0) {
        computedHash = this.hashFour(computedHash, proof[proofIndex], proof[proofIndex + 1], proof[proofIndex + 2]);
      } else if (childIndex === 1) {
        computedHash = this.hashFour(proof[proofIndex], computedHash, proof[proofIndex + 1], proof[proofIndex + 2]);
      } else if (childIndex === 2) {
        computedHash = this.hashFour(proof[proofIndex], proof[proofIndex + 1], computedHash, proof[proofIndex + 2]);
      } else {
        computedHash = this.hashFour(proof[proofIndex], proof[proofIndex + 1], proof[proofIndex + 2], computedHash);
      }

      proofIndex += 3;
      index = Math.floor(index / 4);
    }

    return computedHash === this.root();
  }
}


================================================
FILE: test/scalability/ChannelScalability.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../src/BridgeCore.sol";
import "../../src/BridgeAdminManager.sol";
import "../../src/interface/IBridgeCore.sol";
import "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title ChannelScalabilityTest
 * @notice Proof that channel creation is O(1) regardless of existing channel count
 */
contract SimpleChannelScalabilityTest is Test {
    BridgeCore bridgeCore;
    BridgeAdminManager adminManager;

    address constant TARGET_CONTRACT = address(0x123456);

    function setUp() public {
        bridgeCore = new BridgeCore();
        adminManager = new BridgeAdminManager();

        ERC1967Proxy bridgeCoreProxy = new ERC1967Proxy(
            address(bridgeCore),
            abi.encodeCall(
                bridgeCore.initialize, (address(0), address(0), address(0), address(adminManager), address(this))
            )
        );
        bridgeCore = BridgeCore(address(bridgeCoreProxy));

        ERC1967Proxy adminManagerProxy = new ERC1967Proxy(
            address(adminManager), abi.encodeCall(adminManager.initialize, (address(bridgeCore), address(this)))
        );
        adminManager = BridgeAdminManager(address(adminManagerProxy));

        bridgeCore.updateManagerAddresses(address(0), address(0), address(0), address(adminManager));

        IBridgeCore.PreAllocatedLeaf[] memory emptySlots = new IBridgeCore.PreAllocatedLeaf[](0);
        IBridgeCore.UserStorageSlot[] memory balanceSlot = new IBridgeCore.UserStorageSlot[](1);
        balanceSlot[0] = IBridgeCore.UserStorageSlot({
            slotOffset: 0,
            getterFunctionSignature: bytes32(0),
            isLoadedOnChain: false
        });
        adminManager.setAllowedTargetContract(TARGET_CONTRACT, emptySlots, balanceSlot, true);
    }

    /**
     * @notice Proves channel creation cost is stable across different channel counts
     */
    function testOpenChannelGasStability() public {
        console.log("=== Channel Creation Gas Stability Test ===");

        // Measure first channel
        uint256 gas1 = _measureChannelCreation();
        console.log("Channel #1 gas: %d", gas1);

        // Create 50 more channels
        _createChannels(50);
        uint256 gas51 = _measureChannelCreation();
        console.log("Channel #51 gas: %d", gas51);

        // Create 100 more channels
        _createChannels(100);
        uint256 gas151 = _measureChannelCreation();
        console.log("Channel #151 gas: %d", gas151);

        _createChannels(200);
        uint256 gas351 = _measureChannelCreation();
        console.log("Channel #351 gas: %d", gas351);

        // Analyze results
        uint256 variance1 = gas51 > gas1 ? gas51 - gas1 : gas1 - gas51;
        uint256 variance2 = gas151 > gas1 ? gas151 - gas1 : gas1 - gas151;

        uint256 percentage1 = (variance1 * 100) / gas1;
        uint256 percentage2 = (variance2 * 100) / gas1;

        console.log("Variance from baseline (51 vs 1): %d (%d%%)", variance1, percentage1);
        console.log("Variance from baseline (151 vs 1): %d (%d%%)", variance2, percentage2);

        // Gas should be very stable (within 10%)
        assertLt(percentage1, 10, "Channel 51 should have similar gas to channel 1");
        assertLt(percentage2, 10, "Channel 151 should have similar gas to channel 1");

        console.log("");
        console.log("PROOF COMPLETE: Channel creation is O(1)");
        console.log("No DoS vulnerability exists related to channel count");
    }

    function _measureChannelCreation() internal returns (uint256) {
        address[] memory participants = new address[](2);
        participants[0] = address(0x1001);
        participants[1] = address(0x1002);

        bytes32 channelId = keccak256(abi.encode(address(this), block.timestamp, gasleft()));
        BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
            channelId: channelId,
            targetContract: TARGET_CONTRACT,
            whitelisted: participants,
            enableFrostSignature: false
        });

        address leader = address(uint160(0x8000 + block.number + gasleft()));

        vm.startPrank(leader);
        uint256 gasBeforeChannel = gasleft();
        bridgeCore.openChannel(params);
        uint256 gasAfterChannel = gasleft();
        vm.stopPrank();

        return gasBeforeChannel - gasAfterChannel;
    }

    function _createChannels(uint256 count) internal {
        address[] memory participants = new address[](2);
        participants[0] = address(0x1001);
        participants[1] = address(0x1002);

        for (uint256 i = 0; i < count; i++) {
            bytes32 channelId = keccak256(abi.encode(address(this), i, block.timestamp, gasleft()));
            BridgeCore.ChannelParams memory params = BridgeCore.ChannelParams({
                channelId: channelId,
                targetContract: TARGET_CONTRACT,
                whitelisted: participants,
                enableFrostSignature: false
            });

            address leader = address(uint160(0x9000 + i + block.number + gasleft()));
            vm.startPrank(leader);
            bridgeCore.openChannel(params);
            vm.stopPrank();
        }
    }
}



================================================
FILE: test/verifier/Verifier.t.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import {Test} from "forge-std/Test.sol";
import {TokamakVerifier} from "../../src/verifier/TokamakVerifier.sol";

import "forge-std/console.sol";

contract testTokamakVerifier is Test {
    address owner;

    TokamakVerifier verifier;

    uint128[] public serializedProofPart1;
    uint256[] public serializedProofPart2;
    uint128[] public preprocessedPart1;
    uint256[] public preprocessedPart2;
    uint256[] public publicInputs;
    uint256 public smax;

    function setUp() public virtual {
        verifier = new TokamakVerifier();

        owner = makeAddr("owner");
        vm.startPrank(owner);
        vm.stopPrank();

        // serializedserializedProofPart1: First 16 bytes (32 hex chars) of each coordinate
        // serializedserializedProofPart2: Last 32 bytes (64 hex chars) of each coordinate
        // preprocessedPart1: First 16 bytes (32 hex chars) of each preprocessed committment coordinate
        // preprocessedPart2: last 32 bytes (64 hex chars) of each preprocessed committment coordinate

        /*
        {
    "preprocess_entries_part1": [
    "0x0009bbc7b057876cfc754a192e990683",
    "0x1508f2445c632c43eb3f9df4fc2f1894",
    "0x155cb5eeafb6e4cf7147420e1ce64b17",
    "0x150e9343bcaa1cac0acb160871c5c886"
    ],
    "preprocess_entries_part2": [
    "0x2516192ae1c6b963f3f8e0a1a88b9d669ddbb70cce11452260f4a7c0e71bdbd7",
    "0x60754cda6595f02b2696e5fad29df24e0c9343af6ef16804484b7253261564da",
    "0x6637521519a48e13f11e77f2f3b61bd40ea0a7c2d8d6455b908cd0d943fefa65",
    "0x5bab1505911b91f98e0a7515340ca6bf507c7b7286aff2c079d64acc3a9a26f8"
    ]
        }
        */

        // PREPROCESSED PART 1 (First 16 bytes - 32 hex chars)
        preprocessedPart1.push(0x1136c7a73653af0cbdc9fda441a80391);
        preprocessedPart1.push(0x007c86367643476dcdb0e9bcf1617f1c);
        preprocessedPart1.push(0x18c9e2822155742dd5fbd050aa293be5);
        preprocessedPart1.push(0x00b248168d62853defda478a7a46e0a0);

        // PREPROCESSED PART 2 (Last 32 bytes - 64 hex chars)
        preprocessedPart2.push(0xc4383bb8c86977fc45c94bc42353e37b39907e30b52054990083a85cf5256c22);
        preprocessedPart2.push(0x8fc97f11906d661f0b434c3c49d0ec8b3cac2928f6ff6fac5815686d175d2e87);
        preprocessedPart2.push(0xf84798df0fcfbd79e070d2303170d78e438e4b32975a4ebf6e1ff32863f2cc3e);
        preprocessedPart2.push(0xc6b05d5e144de6e3b25f09093b9ba94c194452d8decf3af3390cfa46df134c0e);

        // SERIALIZED PROOF PART 1 (First 16 bytes - 32 hex chars)
        serializedProofPart1.push(0x15815614b1d3cfda780a76f38debd7a8);
        serializedProofPart1.push(0x15b853b4b6eda1d03dc7425ff8de2ab8);
        serializedProofPart1.push(0x1579e2d3f28e91954ea7f08662b1cf3c);
        serializedProofPart1.push(0x1193fdc21cf50013a57a04b95a980e70);
        serializedProofPart1.push(0x0ef6fa45a824d55e6ab0242e79346af4);
        serializedProofPart1.push(0x0579570790721e06f618e9b435e99fcc);
        serializedProofPart1.push(0x0712c6c5aaa97978302ea53ed788bb9f);
        serializedProofPart1.push(0x0fd202428e1846b62b08551224fc44fa);
        serializedProofPart1.push(0x192da2abb37a61d57edd3cb783519fff);
        serializedProofPart1.push(0x037fecce4bb5d2c935aea5d5dce3eb69);
        serializedProofPart1.push(0x188d99fd3fa3fb713313356e80d011a5);
        serializedProofPart1.push(0x00a815a29deb9b4c2b7f59fad3d0aa70);
        serializedProofPart1.push(0x0dd23c7c26c943439e5793ec06d24027);
        serializedProofPart1.push(0x13af2ab494a3a28b5a9329fcc15e3358);
        serializedProofPart1.push(0x16d79ba31faebbd9be3c5d6ec33405b6);
        serializedProofPart1.push(0x041cb373ead122e1a5755f5e7e11b52a);
        serializedProofPart1.push(0x144bd4c7d0d646d7a50710a2408d10f1);
        serializedProofPart1.push(0x14035301f93670a1083c4bf0410ed855);
        serializedProofPart1.push(0x1106f645a82f2e3098a2d184d5ecce06);
        serializedProofPart1.push(0x12a69c3983176f94b3af657430db1c47);
        serializedProofPart1.push(0x10247238a26ae53c84ad57577454ed6b);
        serializedProofPart1.push(0x1552e5c50974761247a91ad853b5831f);
        serializedProofPart1.push(0x0ed5ac16f53d550faa94b3f89e7c3068);
        serializedProofPart1.push(0x0de8107eff76583c9db6296e542e6f72);
        serializedProofPart1.push(0x059d13674332bae80788f4aad61a36bb);
        serializedProofPart1.push(0x11928ff2162df1dee7bd651f1f06b247);
        serializedProofPart1.push(0x17a05db254eda53ead06061a27b8051a);
        serializedProofPart1.push(0x09cb514bf0ba929adabafa7898023cf3);
        serializedProofPart1.push(0x13eb334743fa8f040a1d288c03872162);
        serializedProofPart1.push(0x1882f3c85de4b5e36314f849a9a35d6c);
        serializedProofPart1.push(0x085686e98ae7c7a0d4ad61f7e1fc2207);
        serializedProofPart1.push(0x0445f9424f1f95b4d831006e7a13f0f0);
        serializedProofPart1.push(0x13eb334743fa8f040a1d288c03872162);
        serializedProofPart1.push(0x1882f3c85de4b5e36314f849a9a35d6c);
        serializedProofPart1.push(0x1674357a821eb6fbd29b19d2bc46bf11);
        serializedProofPart1.push(0x090838093c14b593a824dfe2f491af72);
        serializedProofPart1.push(0x0bf54da2ebdc1f4d8cf126c88c579e2a);
        serializedProofPart1.push(0x04fef23658e5ec9ac987a183ba44f153);

        // SERIALIZED PROOF PART 2 (Last 32 bytes - 64 hex chars)
        serializedProofPart2.push(0x218a2513b9f5d2f07da97b9c001c29cfd1def3795cdc67c7a55aae80d6fa1739);
        serializedProofPart2.push(0x870afac1b023aeb155cd0407035ede2b91c0411f25f3e814419af37045549bf2);
        serializedProofPart2.push(0xb803b959f341ba8d0df34277acf806a22987ee4405bfdb8a6075abab622d8938);
        serializedProofPart2.push(0x4cf5ef5575cc65795c91a41bedd329a870d531132d4c01c0daacfa21ae9d0c9b);
        serializedProofPart2.push(0x5cff38c52fa19d052a230f004a5767cd06f0ee607f235dee61c279901e1eb334);
        serializedProofPart2.push(0x903044616e6a82670d4f0e7da1c2acce49b2f2fdb4bec4d892a6c61a605dabe7);
        serializedProofPart2.push(0x238c8319cab91bf944028e56fdc53fac686912eddb2681bb31da98de1a45046f);
        serializedProofPart2.push(0x72751b0b8849f28e90a043496f8e3c721a9a2c11dc37dfb4b8eb2e51617b838f);
        serializedProofPart2.push(0x1786cc8744ba3c625faf3e425d6efb7fb7a8843f3e7bf849c5bb91aeda51039b);
        serializedProofPart2.push(0xb44c14a62ea7274bfaaeef7f9d177295533ca16b8424c570f40d336f750899c5);
        serializedProofPart2.push(0x0b7e53ae849ff813c770b7fa067c015db95084df6ccfc2d08d7ed344106e9446);
        serializedProofPart2.push(0x903f8c62ade1fe442f896656ccd601dea9f6b884de44ca50179e95b69d7e9278);
        serializedProofPart2.push(0x1a576bce68d74c7f45d2099e21c03ba18b785d4443ca24664a4358b5b4492b07);
        serializedProofPart2.push(0x706a7e78137f8ab4bb6fab55cb7829e4dcd332e07db3233827d57b974ba772c7);
        serializedProofPart2.push(0x08608535f35ba479cbdf98ec4117f1d6d0d5bbbc7120d15975db81ef47084bb1);
        serializedProofPart2.push(0x7a41b65ce8cea584d8903d0e7d311b291df68e8b5cbb2f03aec78b1f632859f3);
        serializedProofPart2.push(0xb51ec8eabaef042a70a4993bae881b2352090b550a0b778918cfa65affcafeb4);
        serializedProofPart2.push(0xab74f4e1b4bb1455e8f57881cc861f7dab291441b019bf6b2b42edff13ab4ff8);
        serializedProofPart2.push(0xd8717ef8b4c49967258125a65a627ffb1039a70986016de2326013298fdad205);
        serializedProofPart2.push(0xb910ebe08c152b86b2cc202f10b89f09bb995327673800c6ff6960cee9fe0fa6);
        serializedProofPart2.push(0x51a0b49263eb04d442553649aa8ba2bff8bf08395e94a40aaf2d6cdf4de5e200);
        serializedProofPart2.push(0x2deddc72de9bd7c8539eb2dbffc05c6d0c6d3dc082211da6b9d2cf6261c5b95c);
        serializedProofPart2.push(0xe90764e8c3c608909905317d1db45264d115e53ff1f5560812e9ad9a712a1aef);
        serializedProofPart2.push(0xf3f16f05a8ac974202fca819ad30654566669e877c575b752e6f2844e8bf811d);
        serializedProofPart2.push(0x7074d02532f74b37b3bf2e2e80e6efd74a59d9c2be7014205f8b0a68da5cf660);
        serializedProofPart2.push(0xb5cb826a1ede3b7eaf370442e4c37560272964a6cacf8d5b7f16a37c376289c9);
        serializedProofPart2.push(0x895f9fab7c3b6d2d2f4c8abab824bce78ebb829d678c9c7893938b1be37797da);
        serializedProofPart2.push(0xe2b5b0dc5b4927868448b343b342c3cbdcc5ed11ec5ca34cafd05d8e1a7d30e5);
        serializedProofPart2.push(0x24a58a466697866ac22e9279dab43ac2b643e6752eedf664396ece2bb61e3e99);
        serializedProofPart2.push(0x4906165f727bdc79f02b6a0b717bacff91e4d980566e205199160e1b84237097);
        serializedProofPart2.push(0x1ae0176fd63ecfa263c5f019842cee0fb2b00c92cdfae64746dd78fc0dd8f58d);
        serializedProofPart2.push(0xf2f32da4b9ea674a98015718df38ef40fd8d4187f23a738ec8fd70902be929d2);
        serializedProofPart2.push(0x24a58a466697866ac22e9279dab43ac2b643e6752eedf664396ece2bb61e3e99);
        serializedProofPart2.push(0x4906165f727bdc79f02b6a0b717bacff91e4d980566e205199160e1b84237097);
        serializedProofPart2.push(0x6ec7a66b4c594cc793e83b44f4da30ad8dd9184f02414a35da49deacc2aeae29);
        serializedProofPart2.push(0x61a58def048a6f157c8c269ce1ff0f622a851eac19fab9060f6cb2e33599eac2);
        serializedProofPart2.push(0x55cc89b9e9e4a9a7c389845c00289a0b8471efb1d4a0bb58c39accb4dc0794a8);
        serializedProofPart2.push(0x2919e53d947ef94f43e16675e04a66b6746bbea448cd8ef68b1c477fa86fc4e9);
        serializedProofPart2.push(0x17fbc25ff5a04b607706778a88332341049268460ee170d1cf06cd64634ee20a);
        serializedProofPart2.push(0x6ead56bfcbba4c416108882629c6c61b940ea05f76cce26606537b96506e15e6);
        serializedProofPart2.push(0x447fff7ec6e9996301a21dbae35881d00d3fc12c7226ba85ff28245be34db010);
        serializedProofPart2.push(0x32fe3527e7bac897c0083e5362f707898d66b4ac5c52bd5004afbe7d713bf6c9);

        // PUBLIC INPUTS (concatenated from instance.json: a_pub_user + a_pub_block + a_pub_function - 512 total)
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x697f6a98de69bdc71426efe52f459cfc);
        publicInputs.push(0x7380218991c8a0feb79bb9715fd26e2a);
        publicInputs.push(0x85e43e3f03778631a09942dd08cf2e8d);
        publicInputs.push(0x4f3d75526b4d4b109e87539730a792e4);
        publicInputs.push(0xe21d7692eebc6214c1585134fda4b0d6);
        publicInputs.push(0x0c8ba5023657fe4b7d7c4edb122894ba);
        publicInputs.push(0x85b8f5c0457dbc3b7c8a280373c40044);
        publicInputs.push(0xa30fe402);
        publicInputs.push(0xa9059cbb);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);

        // a_pub_block (indices 42-65)
        publicInputs.push(0x29dec4629dfb4170647c4ed4efc392cd);
        publicInputs.push(0xf24a01ae);
        publicInputs.push(0x6939333c);
        publicInputs.push(0x00);
        publicInputs.push(0x95abdc);
        publicInputs.push(0x00);
        publicInputs.push(0x19959c1873750220732ca5148bab3254);
        publicInputs.push(0xa0c5ba1cddaf068fc86d068a534eb367);
        publicInputs.push(0x039386c7);
        publicInputs.push(0x00);
        publicInputs.push(0xaa36a7);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xb29b7b4ce683591d957141ca7e4bbc9d);
        publicInputs.push(0x151ac8176283d1313ff21b9d60ad82ce);
        // Rest are zeros (60-65)
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);

        // a_pub_function (indices 66-517) - All the function instance data
        publicInputs.push(0x01);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xe72f6afd7d1f72623e6b071492d1122b);
        publicInputs.push(0x11dafe5d23e1218086a365b99fbf3d3b);
        publicInputs.push(0x3e26ba5cc220fed7cc3f870e59d292aa);
        publicInputs.push(0x1d523cf1ddab1a1793132e78c866c0c3);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x01);
        publicInputs.push(0x00);
        publicInputs.push(0x80);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0x200000);
        publicInputs.push(0x04);
        publicInputs.push(0x00);
        publicInputs.push(0x44);
        publicInputs.push(0x00);
        publicInputs.push(0x010000);
        publicInputs.push(0xe0);
        publicInputs.push(0x00);
        publicInputs.push(0x08000000);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x10000000);
        publicInputs.push(0xe0);
        publicInputs.push(0x00);
        publicInputs.push(0x10000000);
        publicInputs.push(0x70a08231);
        publicInputs.push(0x00);
        publicInputs.push(0x020000);
        publicInputs.push(0x98650275);
        publicInputs.push(0x00);
        publicInputs.push(0x020000);
        publicInputs.push(0xaa271e1a);
        publicInputs.push(0x00);
        publicInputs.push(0x020000);
        publicInputs.push(0x98650275);
        publicInputs.push(0x00);
        publicInputs.push(0x100000);
        publicInputs.push(0xa457c2d7);
        publicInputs.push(0x00);
        publicInputs.push(0x100000);
        publicInputs.push(0xa9059cbb);
        publicInputs.push(0x00);
        publicInputs.push(0x100000);
        publicInputs.push(0x04);
        publicInputs.push(0x00);
        publicInputs.push(0x44);
        publicInputs.push(0x00);
        publicInputs.push(0x08);
        publicInputs.push(0x40);
        publicInputs.push(0x00);
        publicInputs.push(0x010000);
        publicInputs.push(0x200000);
        publicInputs.push(0x02);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x100000);
        publicInputs.push(0x200000);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x100000);
        publicInputs.push(0x200000);
        publicInputs.push(0x60);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x1da9);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x00);
        publicInputs.push(0x020000);
        publicInputs.push(0x200000);
        publicInputs.push(0x08);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x1acc);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x010000);
        publicInputs.push(0x200000);
        publicInputs.push(0x00);
        publicInputs.push(0x00);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0xffffffffffffffffffffffffffffffff);
        publicInputs.push(0xffffffff);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x08);
        publicInputs.push(0x07);
        publicInputs.push(0x00);
        publicInputs.push(0x15);
        publicInputs.push(0x00);
        publicInputs.push(0x0100);
        publicInputs.push(0x00);
        publicInputs.push(0x01);
        publicInputs.push(0x00);
        publicInputs.push(0x10);
        publicInputs.push(0xff);
        publicInputs.push(0x00);
        publicInputs.push(0x200000);
        publicInputs.push(0x200000);
        publicInputs.push(0x01);
        publicInputs.push(0x00);
        publicInputs.push(0x200000);
        publicInputs.push(0x200000);
        publicInputs.push(0x200000);
        publicInputs.push(0x200000);
        publicInputs.push(0x20);
        publicInputs.push(0x00);
        publicInputs.push(0x02);
        publicInputs.push(0x08);
        // Rest are all zeros (247-511)
        for (uint256 i = 247; i < 512; i++) {
            publicInputs.push(0x00);
        }

        smax = 256;
    }

    function testVerifier() public {
        uint256 gasBefore = gasleft();

        // Use low-level call to get the actual bytes returned
        (bool success, bytes memory returnData) = address(verifier).call(
            abi.encodeWithSignature(
                "verify(uint128[],uint256[],uint128[],uint256[],uint256[],uint256)",
                serializedProofPart1,
                serializedProofPart2,
                preprocessedPart1,
                preprocessedPart2,
                publicInputs,
                smax
            )
        );

        uint256 gasAfter = gasleft();
        uint256 gasUsed = gasBefore - gasAfter;

        console.log("Gas used:", gasUsed);
        assert(success == true);
    }

    function testWrongProof_shouldRevert() public {
        serializedProofPart1[4] = 0x0cf3e4f4ddb78781cd5740f3f2a1a3db; // Wrong U_X part1
        serializedProofPart1[5] = 0x0f4b46798d566e5f6653c4fe4df20e83; // Wrong U_Y part1

        serializedProofPart2[4] = 0xd3e45812526acc1d689ce05e186d3a8b9e921ad3a4701013336f3f00c654c908; // Wrong U_X part2
        serializedProofPart2[5] = 0x76983b4b6af2d6a17be232aeeb9fdd374990fdcbd9b1a4654bfbbc5f4bba7e13; // Wrong U_X part2
        vm.expectRevert(bytes("finalPairing: pairing failure"));
        verifier.verify(
            serializedProofPart1, serializedProofPart2, preprocessedPart1, preprocessedPart2, publicInputs, smax
        );
    }

    function testEmptyPublicInput_shouldRevert() public {
        uint256[] memory newPublicInputs;
        vm.expectRevert(bytes("finalPairing: pairing failure"));
        verifier.verify(
            serializedProofPart1, serializedProofPart2, preprocessedPart1, preprocessedPart2, newPublicInputs, smax
        );
    }

    function testWrongSizeProof_shouldRevert() public {
        serializedProofPart1.push(0x0d8838cc826baa7ccd8cfe0692e8a13d); // new point X
        serializedProofPart1.push(0x103aeb959c53fdd5f13b70a350363881); // new point Y
        serializedProofPart2.push(0xbbae56c781b300594dac0753e75154a00b83cc4e6849ef3f07bb56610a02c828); // new point X
        serializedProofPart2.push(0xf3447285889202e7e24cd08a058a758a76ee4c8440131be202ad8bc0cc91ee70); // new point Y

        vm.expectRevert(bytes("loadProof: Proof is invalid"));
        verifier.verify(
            serializedProofPart1, serializedProofPart2, preprocessedPart1, preprocessedPart2, publicInputs, smax
        );
    }

    function testEmptyProof_shouldRevert() public {
        uint128[] memory newserializedProofPart1;
        uint256[] memory newserializedProofPart2;

        vm.expectRevert(bytes("loadProof: Proof is invalid"));
        verifier.verify(
            newserializedProofPart1, newserializedProofPart2, preprocessedPart1, preprocessedPart2, publicInputs, smax
        );
    }
}



================================================
FILE: test/verifier/proof1/channel5_proof1.json
================================================
{
  "proof_entries_part1": [
    "0x1561ed36e27f4d6114d6c8a36fecfbb1",
    "0x0151c14b191da19f77058d03002995a3",
    "0x061377bb72a985cae2bb2797030882d2",
    "0x11777e18043b1b9749450893132706f2",
    "0x1137aee3922f070b4e6ba5634613fdc0",
    "0x0012149cec72fcafb0768b01c498ad90",
    "0x0193c5e28d6259f79d702c2305ed4c5c",
    "0x037ca9373803d90bf2efc2a240f0bb7f",
    "0x0237ebbbb58b3f6a04b37ff0d9ac9399",
    "0x14a5b9d6193fd4fc0064eadbd7da4ea0",
    "0x1070f2aaf5561bbc0ad6feae37683cdd",
    "0x09a7008d70016ee2c31ddc036d73c900",
    "0x0d658b61c53eecbb8bd03dddd4e89f22",
    "0x131ce2ce82a5704e999a047add37fef8",
    "0x05040f5c56f1039d4bf797a46268f811",
    "0x19c1aab945d7bff67198f067e8cd4bca",
    "0x0bdfbcf67209f82e2b8d771ffb70d1a3",
    "0x0cd57182cb964698aa70521a156e1bd0",
    "0x047d30636c10ee797ba34a3e7b11283b",
    "0x0f450b3032222e169606ada1c7590f7a",
    "0x04cd6e9381ce4294eb8e9284b7b6a0ff",
    "0x0db8f57a92e71881e0f9e31edcc5ae44",
    "0x15b11a13bf916d9aab2cb78cd64f3566",
    "0x0599baa32b25ff3d3dd583c59f8f2572",
    "0x0db7fc9b72075dbc10e35326e8faa672",
    "0x14a6ea4023a7d0e859260d6a14d4b304",
    "0x054762b1da9320437d895d0625afe2db",
    "0x13f4de711640e39a875583f516f1a1c6",
    "0x08d7eda32267cde0a6e32c63ebd21d5e",
    "0x05ab7fb2a0fad64c71cebdf6529c60a0",
    "0x0bc7987795b75b73ee11c2f9fd0dec2d",
    "0x094c2b3ac910d852a2d91638c4c0a162",
    "0x08d7eda32267cde0a6e32c63ebd21d5e",
    "0x05ab7fb2a0fad64c71cebdf6529c60a0",
    "0x128febe3228013340969ca4dde497082",
    "0x10d612212485a512165139e73bba6f7f",
    "0x159b8c9cd775a820c4e031bf893e6eb1",
    "0x077c61de01964832198dd609d1b13107"
  ],
  "proof_entries_part2": [
    "0xbf2b11d1737281cfee57678c1a3dbac5cb1607c752b2e29b9c51b4a65b11bb6a",
    "0xff975fd167d92e0445fbb5f52a76ff80ff9e73e5b3260c348b9c2de946e0e9a8",
    "0xaa880a3b4330883e9ae7804fd6d7fbe7080866611eb19639fd054719d71a7c80",
    "0x95d9d6d85e08049ff3f525818d4c3d3ddf1a48e3e6aad229dbc2d6d52db90610",
    "0xf83eb601d793409d08b2d963153cfd83c1bdebea22060c1e3c2a512e239a51ac",
    "0x7f43c8a660b2444e5d207e7c1bf473d200be87f1736bc25925ab8379d78de226",
    "0xfb9badb894e1392d882c84681f81849be36578a940c90058ae0e0ece15b13281",
    "0xd1614c16e95274ec313f398f195b07e16498fc588b41bb298a721ddb746a04cf",
    "0x2f0adb6d6ffccdaa3847b1cd85ea56691e2c0bdefb1531ce9091eed2d5880083",
    "0xf20412a4143ed0da13ba8350159043f888a0da2bde8fd03f9035287c8cda3dbd",
    "0xb5525516dd53081f907163bec4763a46331668139d19caa95f12ee9d6376c005",
    "0xb106c461f58d35224775c49332753fd53ccee0b9c1d56f007961e97f8e9b32e7",
    "0xade59dac77439db65a1adb102a7d7b6f99e731bae0ff154344c7dd0459e3fd26",
    "0x245211fda6e0d1d01cc4ffd5f9a15cd5044eb2c911886a7e25b889234438eecd",
    "0xfc554eb8599bb323da6cfb22998433181522579344f0150fb203442def4b1c90",
    "0x7f57140a268850a01e1759ca87655024c5f6d3a06a69358ec0b001849bcaa5ec",
    "0x3446a9152efa04bad31971c1379484bc6824a03a8c02a40d2d4d3063d6f8ebb2",
    "0xa18c648a8cea127cebd5304ac2b8a7ac88a01f94981f145b54efe7e117a68e0e",
    "0xf8e5e3160a49dcbcf3ca58a8edf3cb1c8fe4a61e3ba859e2e9ef43a2b51eadcb",
    "0xe79b19a74553332f4a7d4e5ff8c1632a0431698c65933f8e51e3532093881a3a",
    "0xcf30c1cd966e711c1e7b1a99aa2aafd9b18be3db497f551cdb4b368ada76ca8e",
    "0x42bc24e057767e0958594088ebed707abb37db29a27da3083a45cff589922cd7",
    "0x6cebbed847a933316f74bb7086e094c9fec1b1690e204a8f0f2cfd827d3b48f5",
    "0x3727f1a8de98e145220fd9d356a23670f05432e4e0bafc5dcf7e84eead5297d1",
    "0x2a20d745ad75f98198b5e81dd4b2f0c631b18b3a813204ac06ef51260f013294",
    "0x3cbebd6ea45fb79c9f76da3ee07a54dc64a73f5efbb03ec8c5086b7163d1a846",
    "0x5a6dfb93bce42687aa9d28192ed7d073f36765b51e7caf99131bfa0815d3cab8",
    "0x9b02180195b1a401a65a31611712f29d8c31ace5820becd52fde473d8d92a6a8",
    "0x0c007d31dc56158c71a102bf80995c445d1e0f707b2f1fedd21bb54018a5e683",
    "0x9111debc1fa2f4f595ab58c4b44b828833bd7b9d78867166d8e9882a36490293",
    "0xd236bcdbcab6d355076130b89aed3eb0491f61674f55621467aea92ee57c7bcc",
    "0x4de31f87e7883b8feeb316733a23fb51b76d75b2b5a2055113368431c9174b74",
    "0x0c007d31dc56158c71a102bf80995c445d1e0f707b2f1fedd21bb54018a5e683",
    "0x9111debc1fa2f4f595ab58c4b44b828833bd7b9d78867166d8e9882a36490293",
    "0xa974ad66b76c4e6fc372795c1ae08a932d2da142358218e25b6e3470d5f2c763",
    "0xe16da42e5597ca36ac1b6a2acefa072847dee1a8e2d29713ad08363ce9e28814",
    "0xdc1d436214be1ed57fcb6015668b4b29ce1e801619b017c23347a0ad0657b731",
    "0xa9e71960ce843e37bbdb8b557614031fe7feeb21cb0c96b27919a86af493fd28",
    "0x3953786e1401544fa78156384c8fd60081b0b7bc7fc361d545c8ffb2f4123b35",
    "0x26cb8034a8a970461a6e75d3ea17d814e5e4c66beb138c0979a6b323af58c13a",
    "0x141ddeb0867939bea66c91055680bc2ff30e3d8a2580a15d62718793f355560e",
    "0x6cb63f94279c385a6de65bce0ac459b52a278f4a2a1c4a7a2fda415ba4d5bff6"
  ],
  "a_pub_user": [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x769375dc5a3b94bcf40f75827be355f8",
    "0x5876a74c8e49224c5997659e57ca9a5b",
    "0x7c4a3489a695f09d962204ae3cb42fd0",
    "0x0bfee9c26c3cd9549157ef90c7a648e7",
    "0xa1de99584b859abf3ecc0a3d8ae22c4d",
    "0x0c2d7a50c82d20362117a77c54dffbad",
    "0x85b8f5c0457dbc3b7c8a280373c40044",
    "0xa30fe402",
    "0xa9059cbb",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ],
  "a_pub_block": [
    "0x4a13a0977f4d7101ebc24b87bb23f0d5",
    "0x13cb6ae3",
    "0x6941286c",
    "0x00",
    "0x965505",
    "0x00",
    "0xaaa74863900cd1aa397b147b5e3a97df",
    "0x3158a0204e0c6977c846dec8dcb483ab",
    "0x03938700",
    "0x00",
    "0xaa36a7",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x08dc98d739f58a805255c068ea55c0bc",
    "0x236aee1beb6982e29d97f81729692e5e",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ],
  "a_pub_function": [
    "0x01",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xe72f6afd7d1f72623e6b071492d1122b",
    "0x11dafe5d23e1218086a365b99fbf3d3b",
    "0x3e26ba5cc220fed7cc3f870e59d292aa",
    "0x1d523cf1ddab1a1793132e78c866c0c3",
    "0x00",
    "0x00",
    "0x01",
    "0x00",
    "0x80",
    "0x00",
    "0x00",
    "0x00",
    "0x200000",
    "0x04",
    "0x00",
    "0x44",
    "0x00",
    "0x010000",
    "0xe0",
    "0x00",
    "0x08000000",
    "0x20",
    "0x00",
    "0x10000000",
    "0xe0",
    "0x00",
    "0x10000000",
    "0x70a08231",
    "0x00",
    "0x020000",
    "0x98650275",
    "0x00",
    "0x020000",
    "0xaa271e1a",
    "0x00",
    "0x020000",
    "0x98650275",
    "0x00",
    "0x100000",
    "0xa457c2d7",
    "0x00",
    "0x100000",
    "0xa9059cbb",
    "0x00",
    "0x100000",
    "0x04",
    "0x00",
    "0x44",
    "0x00",
    "0x08",
    "0x40",
    "0x00",
    "0x010000",
    "0x200000",
    "0x02",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x100000",
    "0x200000",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x100000",
    "0x200000",
    "0x60",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x1da9",
    "0x00",
    "0xffffffff",
    "0x00",
    "0x020000",
    "0x200000",
    "0x08",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x1acc",
    "0x00",
    "0xffffffff",
    "0x00",
    "0x02",
    "0x010000",
    "0x200000",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x08",
    "0x07",
    "0x00",
    "0x15",
    "0x00",
    "0x0100",
    "0x00",
    "0x01",
    "0x00",
    "0x10",
    "0xff",
    "0x00",
    "0x200000",
    "0x200000",
    "0x01",
    "0x00",
    "0x200000",
    "0x200000",
    "0x200000",
    "0x200000",
    "0x20",
    "0x00",
    "0x02",
    "0x08",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]
}


================================================
FILE: test/verifier/proof1/channel5_proof2.json
================================================
{
  "proof_entries_part1": [
    "0x0c597e8d067ec027a89b1d50df61957e",
    "0x1839f50a8395d1525a27a69e74f06912",
    "0x13fac61cd1f73bfea5e6953e6e60b3dc",
    "0x047c09792a826f665fbbca710968f432",
    "0x010db3f03e5e109a14d90ef3330dd591",
    "0x0a20f50ad4099ca62148776c08a20d4c",
    "0x0226161b164c7697e53aa2ba33966090",
    "0x10bc5e57cae070035ee4f86dc10214bd",
    "0x1009da7dfb280ef694a5b9b26b5bf799",
    "0x053cecd0ad95cc095f29ba507097404d",
    "0x056608410082af9d8a01e2e1c1465e9f",
    "0x0daccec848b12ca04cbfa11dfcf4f8f0",
    "0x18330b375928a4027db6e53310ed9669",
    "0x10f6fb277dcb3277cf7dc87e0302e89e",
    "0x15e1e5fdca6d000e1da477c487b41bf2",
    "0x09135e9c4317fcf65d1e740047607b4b",
    "0x1884c5bbb6f838fe2f79602f3d845084",
    "0x0c0a6c31c670cf879bce67ecd679a14e",
    "0x0ae7702e13c3ffdfe1cf7ceb464878e2",
    "0x0750f38845b4e885b7d674ae0a29ff61",
    "0x196d21cc245543853a64a4f9dd62bb26",
    "0x17441de0c9b2623e7544fca3f6d608ba",
    "0x1850d8c3788c59453e8e269528f449d1",
    "0x06f0dde5643c8125a846a32e896634d3",
    "0x021c3fdb09904af0fd058819ef6d47b5",
    "0x090e7739294f93d13d4255452e1af810",
    "0x11a0815a46669fba0e05f56a3669737f",
    "0x032e1fde654804faaf561eb4d2bc0fba",
    "0x0eaef939a6bd2f223c8ef10df3f4f5c6",
    "0x0af7cb70eba5c0790088052d44a12e75",
    "0x0ea486e17e7a492d16e93c25de65df5d",
    "0x0737e4cdda09bd2dea45afc834aa819b",
    "0x0eaef939a6bd2f223c8ef10df3f4f5c6",
    "0x0af7cb70eba5c0790088052d44a12e75",
    "0x12474eee681e9b55658ea783608b167b",
    "0x18238d358dfd1f2cf22ce49c2299d9bf",
    "0x012cef14b72bd5892448c07d8e3f896b",
    "0x1089a6ace6dc814d7c78cf9e609655e3"
  ],
  "proof_entries_part2": [
    "0x3d6796b0cd2ea2d0ce2c804cafb1a4d79f45b6b608c9a59f77f2f489fd022555",
    "0x9ecd891b5c9036beaf5c7f7317f20e7289fc0699d377058802ad1bfb734c2144",
    "0xadd1c702ca34b7e57b21816ace84d310d856161a3ed2f5a6b47bfc6bff769ff1",
    "0x56663f0167a4740f005f90b538a0882824db3d9ffcd6fc71754c805efce4d26e",
    "0xa776e72b0419fb3a4c235e13051d9db126de97523a07329f3b3a33197c33e563",
    "0x6f20930a3ceedd9d3a2f49a3152f69b6d38595d4982ca610ad4fe58398ef22b7",
    "0x7a6e8b177dd09b1c46bd474dd0c1352912584842016a215fd248259f430314b8",
    "0xad3538f4caec7dd096e0c20d0bb7f71859e9415054203b2fd45ef450be1136e8",
    "0xcbc335109f130a1557231c8eac45db3ccbaf06d2766ce70d1cfd3c56be31e814",
    "0x1c8ee0eab1a5f59a48fb06f1d32b2272d99b8ef7adf8a14fa95cf1894204a73b",
    "0xaf7c9ae42281302f9b4ef49f54b0a9b3f020859e8e777cdd47bddfa032cf8b1a",
    "0x111aee3560b669a766e836133302ae8439296ceed46e21ef3180f94e5b066bf7",
    "0xbcdf20618bbf1504fec5feafc051e7d0a84958c60a2cd34f595bead5b3fd253f",
    "0x388be43825c83438cc85da5cc07672944f78173aaad84f58a123eae2be25021c",
    "0x9df2da609d08d3e47a6b99a8127f68f2f96c38836326b0b1f45b6a3a308c1fc0",
    "0x54d85551a30758be3e54ecaef0ae4adacce18da909010f83ccf6acc964571ebd",
    "0xb717a5e820d6df9afde3b9dcdbc745c948155ffc352bc7b5353fd604908164d0",
    "0x0ca39e643140b51d35e20dbc301c22970079505947afb76029092aaa66f77567",
    "0x97528e31eca0f8c2bd0dac17f9d1d36093f7e4ecd72896a6860918bc7447e85b",
    "0xb98aeddc8640d7744c7d8da799cff5772b46c71a5e496949be1584b4d1c5be17",
    "0xb8f5380d34d5b82a41251eca505270aff930d3e288103da1c4fff8ba563a59ea",
    "0x66e9e2aff80e09fad81cccfbaf58723ec8c9e17b407a86eee72d652ed13db317",
    "0xbbe88ce2324b211aa6212bcc499e5ab52479ba571493336bb3e1d4233a593791",
    "0xf8d1ef7647ef6bff2c4939a3f99cf906fa95540d2435c1a95c661ab5b2b4043f",
    "0xcf955c3fa9f77969e7bb5777583c8894320defed8cd3945c4f67bbcd1d2bd3ba",
    "0x12451bf344f6e60b9bad9fe9a30353b7e1fb774a3bfccad699e7b5814bfa5956",
    "0xbf80c257b9ea225dadef9c26590aaf1c560acf7325afb6a924bbd9708595de31",
    "0x4a075db1aa902b86b41638db97ed498bbfe3fe256eadab9d92feaea25a22ff68",
    "0x51845348a7001b321d1aeb82ed3f4e5b519417ae29008199c671079baf6dfdf2",
    "0xf08cb1b6264608f9a3efaf0e1e171596fa62e57b7d6e0f12850e8d33e3cf851c",
    "0x946f3a5b225743dac7ff1b3f240ea9a0705d355b8f71d041bcc82463b4fdfc4d",
    "0xc118c87ae2e4c388410b6a1f1ce302ff9136e8775ed8739b0dff99f6c805bbab",
    "0x51845348a7001b321d1aeb82ed3f4e5b519417ae29008199c671079baf6dfdf2",
    "0xf08cb1b6264608f9a3efaf0e1e171596fa62e57b7d6e0f12850e8d33e3cf851c",
    "0x6776f13b2741f1b90bc575d8168e02b762719d55892b662d3f8eeda5a3340f43",
    "0xe55cab84050a0da7f187187018e8486d30003419fcfd6a5830067e814e968f9f",
    "0x9b84943cc31a11cc5667846a3c9a694ee938f4154203d9777988f044022abe8c",
    "0xdf6d649191183992513651bfb28c4f2e4fc8e19f9bd61c40de261de0a72d1c12",
    "0x185cec5ced27e1e04250c2d0d7febced0a54493f440acf0fcb1449033455986e",
    "0x4e7dfc46cbdbf22d2afb7504acefffd3eb3f6de3d292febe91e95bc605453aaf",
    "0x56f948dcae4b3f3c7b7e4b5ca9c049fce9748b7ae21d64ed84d983b34b6ff114",
    "0x5dd081ac6a8c734f275faa11ebcbe84fa5b6e172b214175727283be9f0bfadb1"
  ],
  "a_pub_user": [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x7c4a3489a695f09d962204ae3cb42fd0",
    "0x0bfee9c26c3cd9549157ef90c7a648e7",
    "0xd7baafc7df716c71558ca0fa9cb261ba",
    "0x70f94af942dafda0a4ffb9d651e610b8",
    "0x8bae88e3ff98a3f1bfcc61e1158affb5",
    "0x0957213fbdf4e57da668994840c99439",
    "0x85b8f5c0457dbc3b7c8a280373c40044",
    "0xa30fe402",
    "0xa9059cbb",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ],
  "a_pub_block": [
    "0x4a13a0977f4d7101ebc24b87bb23f0d5",
    "0x13cb6ae3",
    "0x6941286c",
    "0x00",
    "0x965505",
    "0x00",
    "0xaaa74863900cd1aa397b147b5e3a97df",
    "0x3158a0204e0c6977c846dec8dcb483ab",
    "0x03938700",
    "0x00",
    "0xaa36a7",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x08dc98d739f58a805255c068ea55c0bc",
    "0x236aee1beb6982e29d97f81729692e5e",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ],
  "a_pub_function": [
    "0x01",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xe72f6afd7d1f72623e6b071492d1122b",
    "0x11dafe5d23e1218086a365b99fbf3d3b",
    "0x3e26ba5cc220fed7cc3f870e59d292aa",
    "0x1d523cf1ddab1a1793132e78c866c0c3",
    "0x00",
    "0x00",
    "0x01",
    "0x00",
    "0x80",
    "0x00",
    "0x00",
    "0x00",
    "0x200000",
    "0x04",
    "0x00",
    "0x44",
    "0x00",
    "0x010000",
    "0xe0",
    "0x00",
    "0x08000000",
    "0x20",
    "0x00",
    "0x10000000",
    "0xe0",
    "0x00",
    "0x10000000",
    "0x70a08231",
    "0x00",
    "0x020000",
    "0x98650275",
    "0x00",
    "0x020000",
    "0xaa271e1a",
    "0x00",
    "0x020000",
    "0x98650275",
    "0x00",
    "0x100000",
    "0xa457c2d7",
    "0x00",
    "0x100000",
    "0xa9059cbb",
    "0x00",
    "0x100000",
    "0x04",
    "0x00",
    "0x44",
    "0x00",
    "0x08",
    "0x40",
    "0x00",
    "0x010000",
    "0x200000",
    "0x02",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x100000",
    "0x200000",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x100000",
    "0x200000",
    "0x60",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x1da9",
    "0x00",
    "0xffffffff",
    "0x00",
    "0x020000",
    "0x200000",
    "0x08",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0x1acc",
    "0x00",
    "0xffffffff",
    "0x00",
    "0x02",
    "0x010000",
    "0x200000",
    "0x00",
    "0x00",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x20",
    "0x00",
    "0x02",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0xffffffffffffffffffffffffffffffff",
    "0xffffffff",
    "0x20",
    "0x00",
    "0x02",
    "0x08",
    "0x07",
    "0x00",
    "0x15",
    "0x00",
    "0x0100",
    "0x00",
    "0x01",
    "0x00",
    "0x10",
    "0xff",
    "0x00",
    "0x200000",
    "0x200000",
    "0x01",
    "0x00",
    "0x200000",
    "0x200000",
    "0x200000",
    "0x200000",
    "0x20",
    "0x00",
    "0x02",
    "0x08",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]
}

